{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"simplug","text":"<p>A simple plugin system for Python with async hooks support.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Decorator-based API: Define hooks with <code>@simplug.spec</code> and implement with <code>@simplug.impl</code></li> <li>Async support: First-class async hooks with sync/async bridging</li> <li>Flexible result collection: 18 built-in strategies for collecting plugin results</li> <li>Priority system: Control plugin execution order</li> <li>Setuptools entrypoints: Load plugins from installed packages</li> <li>Singleton per project: Same instance returned for same project name</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U simplug\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from simplug import Simplug\n\n# Create a plugin manager\nsimplug = Simplug('myproject')\n\n# Define a hook specification\nclass MySpec:\n    @simplug.spec\n    def process_data(self, data):\n        \"\"\"Process data in plugins.\"\"\"\n\n# Implement the hook in plugins\nclass PluginA:\n    @simplug.impl\n    def process_data(self, data):\n        return data.upper()\n\nclass PluginB:\n    @simplug.impl\n    def process_data(self, data):\n        return data.lower()\n\n# Register plugins\nsimplug.register(PluginA, PluginB)\n\n# Call the hook\nresults = simplug.hooks.process_data(\"Hello\")\nprint(results)  # ['HELLO', 'hello']\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation is available at https://pwwang.github.io/simplug/</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Define hooks - Specify what plugins can customize</li> <li>Implement hooks - Create plugins with implementations</li> <li>Register plugins - Load plugins into your application</li> <li>Call hooks - Trigger plugin execution</li> </ol> <p>For detailed guides and API reference, see the full documentation.</p>"},{"location":"#examples","title":"Examples","text":"<p>See the examples directory for complete examples: - <code>examples/toy.py</code> - A minimal 30-line demo - <code>examples/complete/</code> - Full example with setuptools entrypoints</p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"examples/","title":"Examples","text":"<p>Collection of simplug examples demonstrating various use cases.</p>"},{"location":"examples/#included-examples","title":"Included Examples","text":""},{"location":"examples/#toy-example","title":"Toy Example","text":"<p>A minimal 30-line demonstration of basic plugin system usage.</p> <p>Location: <code>examples/toy.py</code></p> <p>Features: - Simple hook specification - Multiple plugin implementations - Basic result collection</p> <p>Run: <pre><code>python examples/toy.py\n</code></pre></p> <p>View source: examples/toy.py</p>"},{"location":"examples/#complete-example","title":"Complete Example","text":"<p>Full example with setuptools entry points integration.</p> <p>Location: <code>examples/complete/</code></p> <p>Features: - Complete application structure - Setuptools entry points for plugins - Dynamic plugin loading</p> <p>Run: <pre><code>python -m examples.complete\n</code></pre></p> <p>Install plugin: <pre><code>pip install --editable examples.complete.plugin\npython -m examples.complete\n</code></pre></p> <p>View source: - examples/complete/main.py - examples/complete/plugin/</p>"},{"location":"examples/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/#data-pipeline","title":"Data Pipeline","text":"<pre><code>from simplug import Simplug, SimplugResult\n\nsimplug = Simplug('pipeline')\n\n# Define pipeline stages\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\ndef validate(data):\n    pass\n\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\ndef transform(data):\n    pass\n\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\ndef enrich(data):\n    pass\n\n# Plugins for each stage\nclass SchemaValidator:\n    @simplug.impl\n    def validate(self, data):\n        if not valid_schema(data):\n            raise ValueError(\"Invalid schema\")\n        return True\n\nclass Normalizer:\n    @simplug.impl\n    def transform(self, data):\n        return normalize(data)\n\nclass TimestampEnricher:\n    @simplug.impl\n    def enrich(self, data):\n        data['timestamp'] = datetime.now().isoformat()\n        return data\n\n# Execute pipeline\nvalidated = simplug.hooks.validate(raw_data)\nnormalized = simplug.hooks.transform(validated)\nenriched = simplug.hooks.enrich(normalized)\n</code></pre>"},{"location":"examples/#configuration-management","title":"Configuration Management","text":"<pre><code>from simplug import Simplug, SimplugResult\n\nsimplug = Simplug('configapp')\n\n@simplug.spec(result=SimplugResult.FIRST_AVAIL)\ndef get_config(key):\n    \"\"\"Get config from first available source.\"\"\"\n\n# Priority order: env vars -&gt; file -&gt; defaults\nclass EnvConfig:\n    priority = -1\n\n    @simplug.impl\n    def get_config(self, key):\n        return os.environ.get(key)\n\nclass FileConfig:\n    priority = 0\n\n    @simplug.impl\n    def get_config(self, key):\n        return read_config_file(key)\n\nclass DefaultConfig:\n    priority = 1\n\n    @simplug.impl\n    def get_config(self, key):\n        return DEFAULTS.get(key)\n\n# Use with fallback\ntimeout = simplug.hooks.get_config('timeout')\n# Returns env var if set, else file, else default\n</code></pre>"},{"location":"examples/#event-system","title":"Event System","text":"<pre><code>from simplug import Simplug, SimplugResult\n\nsimplug = Simplug('events')\n\n@simplug.spec(result=SimplugResult.ALL)\ndef on_event(event):\n    pass\n\n# Event subscribers\nclass LoggingPlugin:\n    @simplug.impl\n    def on_event(self, event):\n        logger.info(f\"Event: {event}\")\n\nclass MetricsPlugin:\n    @simplug.impl\n    def on_event(self, event):\n        metrics.increment(event.type)\n\nclass WebhookPlugin:\n    @simplug.impl\n    def on_event(self, event):\n        send_webhook(event)\n\n# Publish event\nsimplug.hooks.on_event({'type': 'user_login', 'user_id': 123})\n# All plugins execute\n</code></pre>"},{"location":"examples/#middleware-chain","title":"Middleware Chain","text":"<pre><code>from simplug import Simplug, SimplugResult\n\nsimplug = Simplug('webapp')\n\n@simplug.spec(result=SimplugResult.ALL)\ndef handle_request(request):\n    pass\n\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\ndef get_response(request):\n    pass\n\nclass AuthPlugin:\n    @simplug.impl\n    def handle_request(self, request):\n        if not authenticated(request):\n            raise UnauthorizedError()\n        return request\n\nclass RateLimitPlugin:\n    @simplug.impl\n    def handle_request(self, request):\n        check_rate_limit(request.user)\n        return request\n\nclass CachingPlugin:\n    @simplug.impl\n    def get_response(self, request):\n        return cache.get(request.url)\n\nclass ProcessingPlugin:\n    @simplug.impl\n    def get_response(self, request):\n        return process_request(request)\n\n# Execute middleware chain\n# All handle_request hooks execute\nresponses = simplug.hooks.get_response(request)\n# First non-None response returned\n</code></pre>"},{"location":"examples/#async-plugin-system","title":"Async Plugin System","text":"<pre><code>import asyncio\nfrom simplug import Simplug, SimplugResult\n\nsimplug = Simplug('asyncapp')\n\n@simplug.spec\nasync def fetch_data(url):\n    pass\n\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\nasync def process_data(data):\n    pass\n\nclass HttpPlugin:\n    @simplug.impl\n    async def fetch_data(self, url):\n        import aiohttp\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as resp:\n                return await resp.text()\n\nclass TransformPlugin:\n    @simplug.impl\n    async def process_data(self, data):\n        await asyncio.sleep(0.1)  # Simulate work\n        return data.upper()\n\nasync def main():\n    data = await simplug.hooks.fetch_data('https://api.example.com/data')\n    results = await simplug.hooks.process_data(data)\n    print(results)\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/#real-world-use-cases","title":"Real-World Use Cases","text":""},{"location":"examples/#web-framework-integration","title":"Web Framework Integration","text":"<p>Define hooks for request/response processing, authentication, and middleware.</p>"},{"location":"examples/#cli-application","title":"CLI Application","text":"<p>Create extensible commands with hooks for argument processing, validation, and output formatting.</p>"},{"location":"examples/#data-processing","title":"Data Processing","text":"<p>Build pipelines with validation, transformation, and enrichment stages.</p>"},{"location":"examples/#monitoring-and-logging","title":"Monitoring and Logging","text":"<p>Allow plugins to subscribe to events and implement custom handlers.</p>"},{"location":"examples/#configuration","title":"Configuration","text":"<p>Support multiple configuration sources with priority-based fallback.</p>"},{"location":"examples/#learning-resources","title":"Learning Resources","text":"<ul> <li>Getting Started - Basic concepts</li> <li>Guides - Feature-specific documentation</li> <li>API Reference - Complete API documentation</li> <li>Source Code - Browse implementation</li> </ul>"},{"location":"examples/#creating-your-own-examples","title":"Creating Your Own Examples","text":"<p>When creating examples:</p> <ol> <li>Keep them simple - Focus on one feature per example</li> <li>Add comments - Explain the key concepts demonstrated</li> <li>Make them runnable - Users should be able to execute immediately</li> <li>Include expected output - Show what to expect</li> <li>Document dependencies - List required packages</li> </ol>"},{"location":"examples/#contributing-examples","title":"Contributing Examples","text":"<p>Have an example that would help others? Consider contributing!</p> <ul> <li>Fork the repository</li> <li>Add your example to <code>examples/</code></li> <li>Update this documentation</li> <li>Submit a pull request</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will walk you through the basics of using simplug to create an extensible application.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install -U simplug\n</code></pre>"},{"location":"getting-started/#basic-concepts","title":"Basic Concepts","text":"<p>simplug has three main concepts:</p> <ol> <li>Plugin Manager (<code>Simplug</code>) - Manages all plugins and hooks</li> <li>Hook Specification (<code>@simplug.spec</code>) - Defines extension points in your application</li> <li>Hook Implementation (<code>@simplug.impl</code>) - Implements hooks in plugins</li> </ol>"},{"location":"getting-started/#step-1-create-a-plugin-manager","title":"Step 1: Create a Plugin Manager","text":"<p>First, create a plugin manager with a unique project name:</p> <pre><code>from simplug import Simplug\n\nsimplug = Simplug('myapp')\n</code></pre> <p>The project name ensures you get the same instance across your application.</p>"},{"location":"getting-started/#step-2-define-hooks","title":"Step 2: Define Hooks","text":"<p>Define hooks that plugins can implement:</p> <pre><code>class MyHooks:\n    @simplug.spec\n    def on_startup(self, config):\n        \"\"\"Called when the application starts.\"\"\"\n\n    @simplug.spec(result=SimplugResult.ALL_AVAILS)\n    def process_data(self, data):\n        \"\"\"Process data and return results.\"\"\"\n</code></pre>"},{"location":"getting-started/#step-3-implement-hooks-in-plugins","title":"Step 3: Implement Hooks in Plugins","text":"<p>Create plugins that implement your hooks:</p> <pre><code>class DataProcessor:\n    @simplug.impl\n    def on_startup(self, config):\n        print(f\"Starting up with config: {config}\")\n\n    @simplug.impl\n    def process_data(self, data):\n        return data.upper()\n\nclass LoggerPlugin:\n    @simplug.impl\n    def on_startup(self, config):\n        print(\"Logger plugin initialized\")\n\n    @simplug.impl\n    def process_data(self, data):\n        print(f\"Processing: {data}\")\n        return data\n</code></pre>"},{"location":"getting-started/#step-4-register-plugins","title":"Step 4: Register Plugins","text":"<p>Register your plugins with the plugin manager:</p> <pre><code>simplug.register(DataProcessor, LoggerPlugin)\n</code></pre> <p>You can also register plugins by module name:</p> <pre><code>simplug.register('mypackage.myplugin')\n</code></pre>"},{"location":"getting-started/#step-5-call-hooks","title":"Step 5: Call Hooks","text":"<p>Execute all plugin implementations of a hook:</p> <pre><code># Call startup hook (all plugins execute)\nsimplug.hooks.on_startup(config={'debug': True})\n\n# Call data processing hook and collect results\nresults = simplug.hooks.process_data(\"Hello\")\nprint(results)  # ['HELLO', None]\n</code></pre>"},{"location":"getting-started/#complete-example","title":"Complete Example","text":"<p>Here's a complete working example:</p> <pre><code>from simplug import Simplug, SimplugResult\n\n# Create plugin manager\nsimplug = Simplug('todoapp')\n\n# Define hooks\nclass TodoHooks:\n    @simplug.spec\n    def add_task(self, task):\n        \"\"\"Add a task.\"\"\"\n\n    @simplug.spec(result=SimplugResult.ALL_AVAILS)\n    def filter_tasks(self, tasks):\n        \"\"\"Filter tasks.\"\"\"\n\n# Implement plugins\nclass PriorityPlugin:\n    @simplug.impl\n    def add_task(self, task):\n        return {**task, 'priority': 'medium'}\n\nclass DatePlugin:\n    @simplug.impl\n    def add_task(self, task):\n        return {**task, 'created': '2024-01-01'}\n\n    @simplug.impl\n    def filter_tasks(self, tasks):\n        return [t for t in tasks if t.get('priority') == 'high']\n\n# Register plugins\nsimplug.register(PriorityPlugin, DatePlugin)\n\n# Use hooks\ntask = {'title': 'Write documentation'}\nenriched = simplug.hooks.add_task(task)\nprint(enriched)  # [{'title': 'Write documentation', 'priority': 'medium'}, {'title': 'Write documentation', 'created': '2024-01-01'}]\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Defining Hooks - Learn about hook options and specifications</li> <li>Implementing Hooks - Deep dive into plugin implementation</li> <li>Result Collection - Explore the 18 result strategies</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"api/simplug/","title":"API Reference","text":"module &lt;/&gt; <p>A simple entrypoint-free plugin system for python</p> Classes <ul> <li><code>SimplugImplCall</code> \u2014 A namedtuple wrapper for hook implementation call.&lt;/&gt;</li> <li><code>SimplugImpl</code> \u2014 A namedtuple wrapper for hook implementation.&lt;/&gt;</li> <li><code>SimplugException</code> \u2014 Base exception class for simplug&lt;/&gt;</li> <li><code>NoSuchPlugin</code> \u2014 When a plugin cannot be imported&lt;/&gt;</li> <li><code>ResultError</code> \u2014 When a result is not available or an error occurs while getting it&lt;/&gt;</li> <li><code>ResultUnavailableError</code> \u2014 When a result is not available&lt;/&gt;</li> <li><code>PluginRegistered</code> \u2014 When a plugin with a name already registered&lt;/&gt;</li> <li><code>NoPluginNameDefined</code> \u2014 When the name of the plugin cannot be found&lt;/&gt;</li> <li><code>HookSignatureDifferentFromSpec</code> \u2014 When the hook signature is different from spec&lt;/&gt;</li> <li><code>NoSuchHookSpec</code> \u2014 When implemented a undefined hook or calling a non-exist hook&lt;/&gt;</li> <li><code>HookRequired</code> \u2014 When a required hook is not implemented&lt;/&gt;</li> <li><code>HookSpecExists</code> \u2014 When a hook has already been defined&lt;/&gt;</li> <li><code>AsyncImplOnSyncSpecError</code> \u2014 When an async implementation on a sync hook&lt;/&gt;</li> <li><code>SyncImplOnAsyncSpecWarning</code> \u2014 When a sync implementation on an async hook&lt;/&gt;</li> <li><code>MultipleImplsForSingleResultHookWarning</code> \u2014 When multiple implementations for a single-result hook&lt;/&gt;</li> <li><code>ImplMightNeedInstanceWarning</code> \u2014 When an implementation might need an instance (self) but not defined as such&lt;/&gt;</li> <li><code>SimplugResult</code> \u2014 Way to get the results from the hooks&lt;/&gt;</li> <li><code>SimplugWrapper</code> \u2014 A wrapper for plugin&lt;/&gt;</li> <li><code>SimplugHook</code> \u2014 A hook of a plugin&lt;/&gt;</li> <li><code>SimplugHookAsync</code> \u2014 Wrapper of an async hook&lt;/&gt;</li> <li><code>SimplugHooks</code> \u2014 The hooks manager&lt;/&gt;</li> <li><code>SimplugContext</code> \u2014 The context manager for enabling or disabling a set of plugins&lt;/&gt;</li> <li><code>Simplug</code> (simplug) \u2014 The plugin manager for simplug&lt;/&gt;</li> </ul> Functions <ul> <li><code>makecall</code><code>(</code><code>call</code>, <code>async_hook</code><code>)</code> (Any) \u2014 Make a call to an implementation and arguments&lt;/&gt;</li> </ul> class &lt;/&gt; Bases tuple <p>A namedtuple wrapper for hook implementation call.</p> Parameters <ul> <li><code>plugin</code> \u2014 The name of the plugin</li> <li><code>impl</code> \u2014 The hook implementation</li> <li><code>args</code> \u2014 The positional arguments</li> <li><code>kwargs</code> \u2014 The keyword arguments</li> </ul> class &lt;/&gt; <p>A namedtuple wrapper for hook implementation.</p><p>This is used to mark the method/function to be an implementation of a hook.</p> Parameters <ul> <li><code>impl</code> (Callable) \u2014 The hook implementation</li> <li><code>has_self</code> (bool) \u2014 Whether the first argument is <code>self</code></li> </ul> Methods <ul> <li><code>__get__</code><code>(</code><code>obj</code>, <code>objtype</code><code>)</code> (simplugimpl) \u2014 Descriptor protocol to make this work as a bound method when accessedon an instance. &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Descriptor protocol to make this work as a bound method when accessedon an instance.</p> class &lt;/&gt; Bases Exception BaseException <p>Base exception class for simplug</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When a plugin cannot be imported</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When a result is not available or an error occurs while getting it</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When a result is not available</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When a plugin with a name already registered</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When the name of the plugin cannot be found</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When the hook signature is different from spec</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When implemented a undefined hook or calling a non-exist hook</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When a required hook is not implemented</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When a hook has already been defined</p> class &lt;/&gt; Bases simplug.SimplugException Exception BaseException <p>When an async implementation on a sync hook</p> class &lt;/&gt; Bases Warning Exception BaseException <p>When a sync implementation on an async hook</p> class &lt;/&gt; Bases Warning Exception BaseException <p>When multiple implementations for a single-result hook</p> class &lt;/&gt; Bases Warning Exception BaseException <p>When an implementation might need an instance (self) but not defined as such</p> class &lt;/&gt; Bases enum.Enum <p>Way to get the results from the hooks</p><p>Available result types: <ul><li>- ALL: Execute all implementations for the hook</li><li>- ALL_AVAILS: Get non-<code>None</code> results</li><li>- FIRST: Get the first result, ordered by priority\u00a0    Don't execute the other implementations</li><li>- LAST: Get the last result, ordered by priority\u00a0    Don't execute the other implementations</li><li>- ALL_FIRST: Get the first result from each implementation and\u00a0    execute the other implementations</li><li>- ALL_LAST: Get the last result from each implementation and\u00a0    execute the other implementations</li><li>- TRY_*: Return <code>None</code> instead of raising <code>ResultUnavailableError</code> when\u00a0    no result is available</li><li>- SINGLE: Get the result from a single implementation</li></ul> Classes <ul> <li><code>EnumType</code> \u2014 Metaclass for Enum&lt;/&gt;</li> </ul> Methods <ul> <li><code>__contains__</code><code>(</code><code>value</code><code>)</code> \u2014 Return True if <code>value</code> is in <code>cls</code>.&lt;/&gt;</li> <li><code>__getitem__</code><code>(</code><code>name</code><code>)</code> \u2014 Return the member matching <code>name</code>.&lt;/&gt;</li> <li><code>__iter__</code><code>(</code><code>)</code> \u2014 Return members in definition order.&lt;/&gt;</li> <li><code>__len__</code><code>(</code><code>)</code> \u2014 Return the number of members (no aliases)&lt;/&gt;</li> </ul> class &lt;/&gt; <p>Metaclass for Enum</p> Attributes <ul> <li><code>__members__</code> \u2014 Returns a mapping of member name-&gt;value.This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. &lt;/&gt;</li> </ul> Methods <ul> <li><code>__bool__</code><code>(</code><code>cls</code><code>)</code> \u2014 classes/types should always be True.&lt;/&gt;</li> <li><code>__call__</code><code>(</code><code>cls</code>, <code>value</code>, <code>names</code>, <code>*values</code>, <code>module</code>, <code>qualname</code>, <code>type</code>, <code>start</code>, <code>boundary</code><code>)</code> \u2014 Either returns an existing member, or creates a new enum class.&lt;/&gt;</li> <li><code>__contains__</code><code>(</code><code>cls</code>, <code>value</code><code>)</code> \u2014 Return True if <code>value</code> is in <code>cls</code>.&lt;/&gt;</li> <li><code>__dir__</code><code>(</code><code>cls</code><code>)</code> \u2014 Specialized dir implementation for types.&lt;/&gt;</li> <li><code>__getitem__</code><code>(</code><code>cls</code>, <code>name</code><code>)</code> \u2014 Return the member matching <code>name</code>.&lt;/&gt;</li> <li><code>__iter__</code><code>(</code><code>cls</code><code>)</code> \u2014 Return members in definition order.&lt;/&gt;</li> <li><code>__len__</code><code>(</code><code>cls</code><code>)</code> \u2014 Return the number of members (no aliases)&lt;/&gt;</li> <li><code>__reversed__</code><code>(</code><code>cls</code><code>)</code> \u2014 Return members in reverse definition order.&lt;/&gt;</li> <li><code>__setattr__</code><code>(</code><code>cls</code>, <code>name</code>, <code>value</code><code>)</code> \u2014 Block attempts to reassign Enum members.&lt;/&gt;</li> </ul> staticmethod <code>__bool__</code><code>(</code><code>cls</code><code>)</code> &lt;/&gt; <p>classes/types should always be True.</p> staticmethod <code>__call__</code><code>(</code><code>cls</code>, <code>value</code>, <code>names=&lt;not given&gt;</code>, <code>*values</code>, <code>module=None</code>, <code>qualname=None</code>, <code>type=None</code>, <code>start=1</code>, <code>boundary=None</code><code>)</code> &lt;/&gt; <p>Either returns an existing member, or creates a new enum class.</p><p>This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')).</p> <p>The value lookup branch is chosen if the enum is final.</p> <p>When used for the functional API:</p> <p><code>value</code> will be the name of the new class.</p> <p><code>names</code> should be either a string of white-space/comma delimited names (values will start at <code>start</code>), or an iterator/mapping of name, value pairs.</p> <p><code>module</code> should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable.</p> <p><code>qualname</code> should be set to the actual location this class can be found at in its module; by default it is set to the global scope.  If this is not correct, unpickling will fail in some circumstances.</p> <p><code>type</code>, if set, will be mixed in as the first base class.</p> staticmethod <code>__contains__</code><code>(</code><code>cls</code>, <code>value</code><code>)</code> &lt;/&gt; <p>Return True if <code>value</code> is in <code>cls</code>.</p><p><code>value</code> is in <code>cls</code> if: 1) <code>value</code> is a member of <code>cls</code>, or 2) <code>value</code> is the value of one of the <code>cls</code>'s members. 3) <code>value</code> is a pseudo-member (flags)</p> staticmethod <code>__dir__</code><code>(</code><code>cls</code><code>)</code> &lt;/&gt; <p>Specialized dir implementation for types.</p> staticmethod <code>__getitem__</code><code>(</code><code>cls</code>, <code>name</code><code>)</code> &lt;/&gt; <p>Return the member matching <code>name</code>.</p> staticmethod <code>__iter__</code><code>(</code><code>cls</code><code>)</code> &lt;/&gt; <p>Return members in definition order.</p> staticmethod <code>__len__</code><code>(</code><code>cls</code><code>)</code> &lt;/&gt; <p>Return the number of members (no aliases)</p> staticmethod <code>__reversed__</code><code>(</code><code>cls</code><code>)</code> &lt;/&gt; <p>Return members in reverse definition order.</p> staticmethod <code>__setattr__</code><code>(</code><code>cls</code>, <code>name</code>, <code>value</code><code>)</code> &lt;/&gt; <p>Block attempts to reassign Enum members.</p><p>A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration.</p> classmethod &lt;/&gt; <p>Return True if <code>value</code> is in <code>cls</code>.</p><p><code>value</code> is in <code>cls</code> if: 1) <code>value</code> is a member of <code>cls</code>, or 2) <code>value</code> is the value of one of the <code>cls</code>'s members. 3) <code>value</code> is a pseudo-member (flags)</p> classmethod &lt;/&gt; <p>Return the member matching <code>name</code>.</p> classmethod &lt;/&gt; <p>Return members in definition order.</p> classmethod &lt;/&gt; <p>Return the number of members (no aliases)</p> function &lt;/&gt; <p>Make a call to an implementation and arguments</p> Parameters <ul> <li><code>call</code> (SimplugImplCall) \u2014 3-element tuple of (implementation, args, kwargs)</li> <li><code>async_hook</code> (bool, optional) \u2014 Whether this is being called from an async hook</li> </ul> Returns (Any) <p>The result of the call</p> class &lt;/&gt; <p>A wrapper for plugin</p> Parameters <ul> <li><code>plugin</code> (Any) \u2014 A object or a string indicating the plugin as a module</li> <li><code>batch_index</code> (int) \u2014 The batch_index when the plugin is registered  simplug = Simplug() simplug.register('plugin1', 'plugin2') # batch 0                 # index:0,  index:1 simplug.register('plugin3', 'plugin4') # batch 1                 # index:0,  index:1 </li> <li><code>index</code> (int) \u2014 The index when the plugin is registered</li> </ul> Attributes <ul> <li><code>is_class</code> \u2014 Whether the plugin is a class&lt;/&gt;</li> <li><code>name</code> \u2014 Try to get the name of the plugin.A lowercase name is recommended. if <code>&lt;plugin&gt;.name</code> is defined, then the name is used. Otherwise, <code>&lt;plugin&gt;.__name__</code> is used. Finally, <code>&lt;plugin&gt;.__class__.__name__</code> is tried. &lt;/&gt;</li> <li><code>plugin</code> \u2014 The raw plugin object</li> <li><code>priority</code> (Tuple) \u2014 A 2-element tuple used to prioritize the plugins<ul><li>- If <code>plugin.priority</code> is specified, use it as the first element\u00a0    and batch_index will be the second element</li><li>- Otherwise, batch_index the first and index the second.</li><li>- Smaller number has higher priority</li><li>- Negative numbers allowed</li></ul></li> <li><code>version</code> \u2014 Try to get the version of the plugin.If the attribute <code>version</code> is definied, use it. Otherwise, try to check if <code>__version__</code> is defined. If neither is defined, return None. &lt;/&gt;</li> </ul> Raises <ul> <li><code>NoSuchPlugin</code> \u2014 When a string is passed in and the plugin cannot beimported as a module </li> </ul> Methods <ul> <li><code>disable</code><code>(</code><code>)</code> \u2014 Disable this plugin&lt;/&gt;</li> <li><code>enable</code><code>(</code><code>)</code> \u2014 Enable this plugin&lt;/&gt;</li> <li><code>hook</code><code>(</code><code>name</code><code>)</code> (Optional) \u2014 Get the hook implementation of this plugin by name&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Enable this plugin</p> method &lt;/&gt; <p>Disable this plugin</p> method &lt;/&gt; <p>Get the hook implementation of this plugin by name</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name of the hook</li> </ul> Returns (Optional) <p>The wrapper of the implementation. If the implementation is not    found or it's not decorated by <code>simplug.impl</code>, None will be     returned.</p> class &lt;/&gt; <p>A hook of a plugin</p> Parameters <ul> <li><code>simplug_hooks</code> (simplughooks) \u2014 The SimplugHooks object</li> <li><code>spec</code> (Callable) \u2014 The specification of the hook</li> <li><code>required</code> (bool) \u2014 Whether this hook is required to be implemented</li> <li><code>result</code> (Union) \u2014 Way to collect the results from the hook</li> </ul> Attributes <ul> <li><code>debug</code> \u2014 Whether to print debug messages</li> <li><code>name</code> \u2014 The name of the hook</li> <li><code>required</code> \u2014 Whether this hook is required to be implemented</li> <li><code>result</code> \u2014 Way to collect the results from the hook</li> <li><code>simplug_hooks</code> \u2014 The SimplugHooks object</li> <li><code>spec</code> \u2014 The specification of the hook</li> <li><code>warn_sync_impl_on_async</code> \u2014 Whether to warn about sync implementationson async hooks </li> </ul> Methods <ul> <li><code>__call__</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> (Depending on `self.result`) \u2014 Call the hook in your system&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Call the hook in your system</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 args for the hook</li> <li><code>**kwargs</code> (Any) \u2014 kwargs for the hook</li> </ul> Returns (Depending on `self.result`) <p>ts , s e ) m y</p> class &lt;/&gt; Bases simplug.SimplugHook <p>Wrapper of an async hook</p> Parameters <ul> <li><code>simplug_hooks</code> (simplughooks) \u2014 The SimplugHooks object</li> <li><code>spec</code> (Callable) \u2014 The specification of the hook</li> <li><code>required</code> (bool) \u2014 Whether this hook is required to be implemented</li> <li><code>result</code> (Union) \u2014 Way to collect the results from the hook</li> </ul> Attributes <ul> <li><code>debug</code> \u2014 Whether to print debug messages</li> <li><code>name</code> \u2014 The name of the hook</li> <li><code>required</code> \u2014 Whether this hook is required to be implemented</li> <li><code>result</code> \u2014 Way to collect the results from the hook</li> <li><code>simplug_hooks</code> \u2014 The SimplugHooks object</li> <li><code>spec</code> \u2014 The specification of the hook</li> <li><code>warn_sync_impl_on_async</code> \u2014 Whether to warn about sync implementationson async hooks </li> </ul> Methods <ul> <li><code>__call__</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> (Depending on `self.result`) \u2014 Call the hook in your system asynchronously&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Call the hook in your system asynchronously</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 args for the hook</li> <li><code>**kwargs</code> (Any) \u2014 kwargs for the hook</li> </ul> Returns (Depending on `self.result`) <p>ts , s e ) m y</p> class &lt;/&gt; <p>The hooks manager</p><p>Methods in this class are prefixed with a underscore to attributes clean for hooks.</p> <p>To call a hook in your system: <pre><code>&gt;&gt;&gt; simplug.hooks.&lt;hook_name&gt;(&lt;args&gt;)\n</code></pre></p> Attributes <ul> <li><code>_registry</code> \u2014 The plugin registry</li> <li><code>_registry_sorted</code> \u2014 Whether the plugin registry has been sorted already</li> <li><code>_specs</code> (Dict) \u2014 The registry for the hook specs</li> </ul> Methods <ul> <li><code>__getattr__</code><code>(</code><code>name</code><code>)</code> (Union) \u2014 Get the hook by name&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Get the hook by name</p> Parameters <ul> <li><code>name</code> (str) \u2014 The hook name</li> </ul> Returns (Union) <p>The SimplugHook object</p> Raises <ul> <li><code>NoSuchHookSpec</code> \u2014 When the hook has no specification defined.</li> </ul> class &lt;/&gt; <p>The context manager for enabling or disabling a set of plugins</p> class &lt;/&gt; <p>The plugin manager for simplug</p> Attributes <ul> <li><code>PROJECTS</code> \u2014 The projects registry, to make sure the same <code>Simplug</code>object by the name project name. </li> <li><code>_batch_index</code> \u2014 The batch index for plugin registration</li> <li><code>_inited</code> \u2014 Whether <code>__init__</code> has already been called. Since the<code>__init__</code> method will be called after <code>__new__</code>, this is used to avoid <code>__init__</code> to be called more than once </li> <li><code>hooks</code> \u2014 The hooks manager</li> </ul> Methods <ul> <li><code>disable</code><code>(</code><code>*names</code><code>)</code> \u2014 Disable plugins by names&lt;/&gt;</li> <li><code>enable</code><code>(</code><code>*names</code><code>)</code> \u2014 Enable plugins by names&lt;/&gt;</li> <li><code>get_all_plugin_names</code><code>(</code><code>)</code> (List) \u2014 Get the names of all plugins&lt;/&gt;</li> <li><code>get_all_plugins</code><code>(</code><code>raw</code><code>)</code> (Dict) \u2014 Get a mapping of all plugins&lt;/&gt;</li> <li><code>get_enabled_plugin_names</code><code>(</code><code>)</code> (List) \u2014 Get the names of all enabled plugins&lt;/&gt;</li> <li><code>get_enabled_plugins</code><code>(</code><code>raw</code><code>)</code> (Dict) \u2014 Get a mapping of all enabled plugins&lt;/&gt;</li> <li><code>get_plugin</code><code>(</code><code>name</code>, <code>raw</code><code>)</code> (Union) \u2014 Get the plugin wrapper or the raw plugin object&lt;/&gt;</li> <li><code>impl</code><code>(</code><code>hook</code><code>)</code> (SimplugImpl) \u2014 A decorator for the implementation of a hook&lt;/&gt;</li> <li><code>load_entrypoints</code><code>(</code><code>group</code>, <code>only</code><code>)</code> \u2014 Load plugins from setuptools entry_points&lt;/&gt;</li> <li><code>plugins_context</code><code>(</code><code>plugins</code><code>)</code> (Union) \u2014 A context manager with given plugins enabled or disabled&lt;/&gt;</li> <li><code>register</code><code>(</code><code>*plugins</code><code>)</code> \u2014 Register plugins&lt;/&gt;</li> <li><code>spec</code><code>(</code><code>hook</code>, <code>required</code>, <code>result</code>, <code>warn_sync_impl_on_async</code><code>)</code> (Callable) \u2014 A decorator to define the specification of a hook&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Load plugins from setuptools entry_points</p> Parameters <ul> <li><code>group</code> (Optional, optional) \u2014 The group of the entry_points</li> <li><code>only</code> (Union, optional) \u2014 The names of the entry_points to load. If it's a str, itmeans only load this entry_point. If it's a list of str, it means load all the entry_points in the list. </li> </ul> method &lt;/&gt; <p>Register plugins</p> Parameters <ul> <li><code>*plugins</code> (Any) \u2014 The plugins, each of which could be a str, indicatingthat the plugin is a module and will be imported by <code>__import__</code>; or an object with the hook implementations as its attributes. </li> </ul> method &lt;/&gt; <p>Get the plugin wrapper or the raw plugin object</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name of the plugin</li> <li><code>raw</code> (bool, optional) \u2014 Get the raw plugin object (the one when it's registered)If a plugin is a module and registered by its name, the module is returned </li> </ul> Raises <ul> <li><code>NoSuchPlugin</code> \u2014 When the plugin does not exist</li> </ul> Returns (Union) <p>The plugin wrapper or raw plugin</p> method &lt;/&gt; <p>Get a mapping of all plugins</p> Parameters <ul> <li><code>raw</code> (bool, optional) \u2014 Whether return the raw plugin or not(the one when it's registered) If a plugin is registered as a module by its name, the module is returned. </li> </ul> Returns (Dict) <p>The mapping of all plugins</p> method &lt;/&gt; <p>Get a mapping of all enabled plugins</p> Parameters <ul> <li><code>raw</code> (bool, optional) \u2014 Whether return the raw plugin or not(the one when it's registered) If a plugin is registered as a module by its name, the module is returned. </li> </ul> Returns (Dict) <p>The mapping of all enabled plugins</p> method &lt;/&gt; <p>Get the names of all plugins</p> Returns (List) <p>The names of all plugins</p> method &lt;/&gt; <p>Get the names of all enabled plugins</p> Returns (List) <p>The names of all enabled plugins</p> method &lt;/&gt; <p>A context manager with given plugins enabled or disabled</p> Parameters <ul> <li><code>plugins</code> (Optional) \u2014 The plugin names or plugin objectsIf the given plugin does not exist, register it. None to not enable or disable anything. When the context exits, the original status of the plugins will be restored. You can use <code>+</code> or <code>-</code> to enable or disable a plugin. If a plugin is already enabled or disabled, it will be ignored. If a plugin name is given without a prefix, it will be enabled and all other plugins will be disabled. If a plugin is given as a plugin itself, not a name, it will be regarded as <code>+</code>. </li> </ul> Examples <pre><code>&gt;&gt;&gt; # enabled: plugin1, plugin2; disabled: plugin3&gt;&gt;&gt; with simplug.plugins_context(['plugin3']):\n&gt;&gt;&gt;     # enabled: plugin3; disabled: plugin1, plugin2\n&gt;&gt;&gt;     pass\n&gt;&gt;&gt; # enabled: plugin1, plugin2; disabled: plugin3\n&gt;&gt;&gt; with simplug.plugins_context(['+plugin3']):\n&gt;&gt;&gt;     # enabled: plugin1, plugin2, plugin3\n&gt;&gt;&gt;     pass\n&gt;&gt;&gt; # enabled: plugin1, plugin2; disabled: plugin3\n&gt;&gt;&gt; with simplug.plugins_context(['-plugin1']):\n&gt;&gt;&gt;     # enabled: plugin2; disabled: plugin1, plugin3\n&gt;&gt;&gt;     pass\n&gt;&gt;&gt; # enabled: plugin1, plugin2; disabled: plugin3\n&gt;&gt;&gt; with simplug.plugins_context(['-plugin1', '+plugin3']):\n&gt;&gt;&gt;     # enabled: plugin2, plugin3; disabled: plugin1\n&gt;&gt;&gt;     pass\n</code></pre> Returns (Union) <p>The context manager</p> method &lt;/&gt; <p>Enable plugins by names</p> Parameters <ul> <li><code>*names</code> (str) \u2014 The names of the plugin</li> </ul> method &lt;/&gt; <p>Disable plugins by names</p> Parameters <ul> <li><code>names</code> \u2014 The names of the plugin</li> </ul> method &lt;/&gt; <p>A decorator to define the specification of a hook</p> Parameters <ul> <li><code>hook</code> (Optional, optional) \u2014 The hook spec. If it is None, that means this decorator iscalled with arguments, and it should be keyword arguments. Otherwise, it is called like this <code>simplug.spec</code> </li> <li><code>required</code> (bool, optional) \u2014 Whether this hook is required to be implemented.</li> <li><code>result</code> (Union, optional) \u2014 How should we collect the results from the plugins</li> <li><code>warn_sync_impl_on_async</code> (bool, optional) \u2014 Whether to warn when a sync implementation</li> </ul> Raises <ul> <li><code>HookSpecExists</code> \u2014 If a hook spec with the same name (<code>hook.__name__</code>)is already defined. </li> </ul> Returns (Callable) <p>A decorator function of other argument is passed, or the hook spec    itself.</p> method &lt;/&gt; <p>A decorator for the implementation of a hook</p> Parameters <ul> <li><code>hook</code> (Callable) \u2014 The hook implementation</li> </ul> Raises <ul> <li><code>NoSuchHookSpec</code> \u2014 When no specification is defined for this hook</li> </ul> Returns (SimplugImpl) <p>The wrapped hook implementation by <code>SimplugImpl</code></p>"},{"location":"api/simplug/#simplug","title":"simplug","text":""},{"location":"api/simplug/#simplugsimplugimplcall","title":"<code>simplug.</code><code>SimplugImplCall</code><code>(</code><code>plugin</code>, <code>impl</code>, <code>args</code>, <code>kwargs</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugimpl","title":"<code>simplug.</code><code>SimplugImpl</code><code>(</code><code>impl</code>, <code>has_self</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugimplget","title":"<code>__get__</code><code>(</code><code>obj</code>, <code>objtype=None</code><code>)</code> \u2192 simplugimpl","text":""},{"location":"api/simplug/#simplugsimplugexception","title":"<code>simplug.</code><code>SimplugException</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugnosuchplugin","title":"<code>simplug.</code><code>NoSuchPlugin</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugresulterror","title":"<code>simplug.</code><code>ResultError</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugresultunavailableerror","title":"<code>simplug.</code><code>ResultUnavailableError</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugpluginregistered","title":"<code>simplug.</code><code>PluginRegistered</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugnopluginnamedefined","title":"<code>simplug.</code><code>NoPluginNameDefined</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplughooksignaturedifferentfromspec","title":"<code>simplug.</code><code>HookSignatureDifferentFromSpec</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugnosuchhookspec","title":"<code>simplug.</code><code>NoSuchHookSpec</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplughookrequired","title":"<code>simplug.</code><code>HookRequired</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplughookspecexists","title":"<code>simplug.</code><code>HookSpecExists</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugasyncimplonsyncspecerror","title":"<code>simplug.</code><code>AsyncImplOnSyncSpecError</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsyncimplonasyncspecwarning","title":"<code>simplug.</code><code>SyncImplOnAsyncSpecWarning</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugmultipleimplsforsingleresulthookwarning","title":"<code>simplug.</code><code>MultipleImplsForSingleResultHookWarning</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugimplmightneedinstancewarning","title":"<code>simplug.</code><code>ImplMightNeedInstanceWarning</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugresult","title":"<code>simplug.</code><code>SimplugResult</code><code>(</code><code>*values</code><code>)</code>","text":""},{"location":"api/simplug/#enumenumtype","title":"<code>enum.</code><code>EnumType</code><code>(</code><code>cls</code>, <code>bases</code>, <code>classdict</code>, <code>boundary=None</code>, <code>_simple=False</code>, <code>**kwds</code><code>)</code>","text":""},{"location":"api/simplug/#enumenumtypecontains","title":"<code>__contains__</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/simplug/#enumenumtypegetitem","title":"<code>__getitem__</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/simplug/#enumenumtypeiter","title":"<code>__iter__</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#enumenumtypelen","title":"<code>__len__</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugmakecall","title":"<code>simplug.</code><code>makecall</code><code>(</code><code>call</code>, <code>async_hook=False</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugwrapper","title":"<code>simplug.</code><code>SimplugWrapper</code><code>(</code><code>plugin</code>, <code>batch_index</code>, <code>index</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugwrapperenable","title":"<code>enable</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugwrapperdisable","title":"<code>disable</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugwrapperhook","title":"<code>hook</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplughook","title":"<code>simplug.</code><code>SimplugHook</code><code>(</code><code>simplug_hooks</code>, <code>spec</code>, <code>required</code>, <code>result</code>, <code>warn_sync_impl_on_async=False</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplughookcall","title":"<code>__call__</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplughookasync","title":"<code>simplug.</code><code>SimplugHookAsync</code><code>(</code><code>simplug_hooks</code>, <code>spec</code>, <code>required</code>, <code>result</code>, <code>warn_sync_impl_on_async=False</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplughookasynccall","title":"<code>__call__</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplughooks","title":"<code>simplug.</code><code>SimplugHooks</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplughooksgetattr","title":"<code>__getattr__</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugcontext","title":"<code>simplug.</code><code>SimplugContext</code><code>(</code><code>simplug</code>, <code>plugins</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplug","title":"<code>simplug.</code><code>Simplug</code><code>(</code><code>project</code><code>)</code> \u2192 simplug","text":""},{"location":"api/simplug/#simplugsimplugload_entrypoints","title":"<code>load_entrypoints</code><code>(</code><code>group=None</code>, <code>only=()</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugregister","title":"<code>register</code><code>(</code><code>*plugins</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugget_plugin","title":"<code>get_plugin</code><code>(</code><code>name</code>, <code>raw=False</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugget_all_plugins","title":"<code>get_all_plugins</code><code>(</code><code>raw=False</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugget_enabled_plugins","title":"<code>get_enabled_plugins</code><code>(</code><code>raw=False</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugget_all_plugin_names","title":"<code>get_all_plugin_names</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugget_enabled_plugin_names","title":"<code>get_enabled_plugin_names</code><code>(</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugplugins_context","title":"<code>plugins_context</code><code>(</code><code>plugins</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugenable","title":"<code>enable</code><code>(</code><code>*names</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugdisable","title":"<code>disable</code><code>(</code><code>*names</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugspec","title":"<code>spec</code><code>(</code><code>hook=None</code>, <code>required=False</code>, <code>result=&lt;SimplugResult.ALL_AVAILS: 49&gt;</code>, <code>warn_sync_impl_on_async=True</code><code>)</code>","text":""},{"location":"api/simplug/#simplugsimplugimpl_1","title":"<code>impl</code><code>(</code><code>hook</code><code>)</code>","text":""},{"location":"api/source/simplug/","title":"simplug","text":""},{"location":"api/source/simplug/","title":"SOURCE CODE simplug DOCS","text":"<pre><code>\"\"\"A simple entrypoint-free plugin system for python\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport inspect\nimport warnings\nfrom collections import namedtuple\nfrom contextlib import nullcontext\nfrom enum import Enum\nfrom importlib import import_module, metadata\nfrom typing import Any, Callable, Dict, Iterable, List, Tuple, Union, Optional\n\nfrom diot import OrderedDiot\n\n__version__ = \"0.5.6\"\n\n\nclass SimplugImpl:DOCS\n    \"\"\"A namedtuple wrapper for hook implementation.\n\n    This is used to mark the method/function to be an implementation of a hook.\n\n    Args:\n        impl: The hook implementation\n        has_self: Whether the first argument is `self`\n    \"\"\"\n\n    __slots__ = (\"impl\", \"has_self\")\n\n    def __init__(self, impl: Callable, has_self: bool):\n        self.impl = impl\n        self.has_self = has_self\n\n    def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n        return self.impl(*args, **kwds)\n\n    def __get__(self, obj: Any, objtype: type | None = None) -&gt; \"SimplugImpl\":DOCS\n        \"\"\"Descriptor protocol to make this work as a bound method when accessed\n        on an instance.\"\"\"\n        if obj is None:\n            # When accessed on the class, return the SimplugImpl itself\n            return self\n        if self.has_self:\n            # Return a bound method-like callable that auto-passes the instance\n            # but still appears as a SimplugImpl\n            class BoundSimplugImpl(SimplugImpl):\n                def __init__(self, original_impl: \"SimplugImpl\", instance: Any) -&gt; None:\n                    super().__init__(original_impl.impl, original_impl.has_self)\n                    self.instance = instance\n\n                def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n                    return self.impl(self.instance, *args, **kwargs)\n\n                def __get__(\n                    self, obj: Any, objtype: type | None = None\n                ) -&gt; \"SimplugImpl\":  # pragma: no cover\n                    # Handle super() calls - when accessed on another instance\n                    if obj is None:\n                        return self\n                    # For super() calls, we want to call with the new instance\n                    # Create a new bound method for the new instance\n                    return BoundSimplugImpl(SimplugImpl(self.impl, self.has_self), obj)\n\n            return BoundSimplugImpl(self, obj)\n        else:\n            # For non-self methods, still return the original SimplugImpl\n            return self\n\n\nSimplugImplCall = namedtuple(\n    \"SimplugImplCall\",\n    [\"plugin\", \"impl\", \"args\", \"kwargs\"],\n)\nSimplugImplCall.__doc__ = \"\"\"A namedtuple wrapper for hook implementation call.\n\nArgs:\n    plugin: The name of the plugin\n    impl: The hook implementation\n    args: The positional arguments\n    kwargs: The keyword arguments\n\"\"\"\n\n\nclass SimplugException(Exception):DOCS\n    \"\"\"Base exception class for simplug\"\"\"\n\n\nclass NoSuchPlugin(SimplugException):DOCS\n    \"\"\"When a plugin cannot be imported\"\"\"\n\n\nclass ResultError(SimplugException):DOCS\n    \"\"\"When a result is not available or an error occurs while getting it\"\"\"\n\n\nclass ResultUnavailableError(SimplugException):DOCS\n    \"\"\"When a result is not available\"\"\"\n\n\nclass PluginRegistered(SimplugException):DOCS\n    \"\"\"When a plugin with a name already registered\"\"\"\n\n\nclass NoPluginNameDefined(SimplugException):DOCS\n    \"\"\"When the name of the plugin cannot be found\"\"\"\n\n\nclass HookSignatureDifferentFromSpec(SimplugException):DOCS\n    \"\"\"When the hook signature is different from spec\"\"\"\n\n\nclass NoSuchHookSpec(SimplugException):DOCS\n    \"\"\"When implemented a undefined hook or calling a non-exist hook\"\"\"\n\n\nclass HookRequired(SimplugException):DOCS\n    \"\"\"When a required hook is not implemented\"\"\"\n\n\nclass HookSpecExists(SimplugException):DOCS\n    \"\"\"When a hook has already been defined\"\"\"\n\n\nclass AsyncImplOnSyncSpecError(SimplugException):DOCS\n    \"\"\"When an async implementation on a sync hook\"\"\"\n\n\nclass SyncImplOnAsyncSpecWarning(Warning):DOCS\n    \"\"\"When a sync implementation on an async hook\"\"\"\n\n\nclass MultipleImplsForSingleResultHookWarning(Warning):DOCS\n    \"\"\"When multiple implementations for a single-result hook\"\"\"\n\n\nclass ImplMightNeedInstanceWarning(Warning):DOCS\n    \"\"\"When an implementation might need an instance (self) but not defined as such\"\"\"\n\n\nclass SimplugResult(Enum):DOCS\n    \"\"\"Way to get the results from the hooks\n\n    Available result types:\n    - ALL: Execute all implementations for the hook\n    - ALL_AVAILS: Get non-`None` results\n    - FIRST: Get the first result, ordered by priority\n        Don't execute the other implementations\n    - LAST: Get the last result, ordered by priority\n        Don't execute the other implementations\n    - ALL_FIRST: Get the first result from each implementation and\n        execute the other implementations\n    - ALL_LAST: Get the last result from each implementation and\n        execute the other implementations\n    - TRY_*: Return `None` instead of raising `ResultUnavailableError` when\n        no result is available\n    - SINGLE: Get the result from a single implementation\n    \"\"\"\n\n    # 0b  1    1    1    1111\n    #    TRY  ALL AVAIL   ID\n    ALL = 0b010_0000  # 64\n    ALL_AVAILS = 0b011_0001  # 97\n    ALL_FIRST = 0b010_0010  # 66\n    TRY_ALL_FIRST = 0b110_0010  # 194\n    ALL_LAST = 0b010_0011  # 67\n    TRY_ALL_LAST = 0b110_0011  # 195\n    ALL_FIRST_AVAIL = 0b011_0100  # 102\n    TRY_ALL_FIRST_AVAIL = 0b111_0100  # 230\n    ALL_LAST_AVAIL = 0b011_0101  # 103\n    TRY_ALL_LAST_AVAIL = 0b111_0101  # 231\n    FIRST = 0b000_0110  # 10\n    TRY_FIRST = 0b100_0110  # 138\n    LAST = 0b000_0111  # 11\n    TRY_LAST = 0b100_0111  # 139\n    FIRST_AVAIL = 0b001_1000  # 46\n    TRY_FIRST_AVAIL = 0b101_1000  # 174\n    LAST_AVAIL = 0b001_1001  # 47\n    TRY_LAST_AVAIL = 0b101_1001  # 175\n    SINGLE = 0b000_1010  # 18\n    TRY_SINGLE = 0b100_1010  # 146\n\n\ndef makecall(call: SimplugImplCall, async_hook: bool = False) -&gt; Any:DOCS\n    \"\"\"Make a call to an implementation and arguments\n\n    Args:\n        call: 3-element tuple of (implementation, args, kwargs)\n        async_hook: Whether this is being called from an async hook\n\n    Returns:\n        The result of the call\n    \"\"\"\n    spec_prefix = \"[async]\" if async_hook else \"\"\n    err_msg = (\n        \"Error while calling hook implementation, \"\n        f\"plugin={call.plugin}; spec={spec_prefix}{call.impl.__name__}\"\n    )\n    if inspect.iscoroutinefunction(call.impl):\n\n        async def coro():\n            try:\n                return await call.impl(*call.args, **call.kwargs)\n            except Exception as exc:\n                raise ResultError(err_msg) from exc\n\n        return coro()\n\n    try:\n        out = call.impl(*call.args, **call.kwargs)\n    except Exception as exc:\n        raise ResultError(err_msg) from exc\n\n    if async_hook:\n\n        async def coro():\n            return out\n\n        return coro()\n\n    return out\n\n\nclass SimplugWrapper:DOCS\n    \"\"\"A wrapper for plugin\n\n    Args:\n        plugin: A object or a string indicating the plugin as a module\n        batch_index: The batch_index when the plugin is registered\n            &gt;&gt;&gt; simplug = Simplug()\n            &gt;&gt;&gt; simplug.register('plugin1', 'plugin2') # batch 0\n            &gt;&gt;&gt;                 # index:0,  index:1\n            &gt;&gt;&gt; simplug.register('plugin3', 'plugin4') # batch 1\n            &gt;&gt;&gt;                 # index:0,  index:1\n        index: The index when the plugin is registered\n\n    Attributes:\n        plugin: The raw plugin object\n        priority: A 2-element tuple used to prioritize the plugins\n            - If `plugin.priority` is specified, use it as the first element\n                and batch_index will be the second element\n            - Otherwise, batch_index the first and index the second.\n            - Smaller number has higher priority\n            - Negative numbers allowed\n\n    Raises:\n        NoSuchPlugin: When a string is passed in and the plugin cannot be\n            imported as a module\n    \"\"\"\n\n    plugin: Any\n    _name: Optional[str]\n    priority: Tuple[int, int]\n    enabled: bool\n\n    def __init__(self, plugin: Any, batch_index: int, index: int) -&gt; None:\n        self.plugin = self._name = None\n        if isinstance(plugin, str):\n            try:\n                self.plugin = import_module(plugin)\n            except ImportError as exc:\n                raise NoSuchPlugin(plugin).with_traceback(exc.__traceback__) from None\n\n        elif isinstance(plugin, tuple):\n            # plugin load from entrypoint\n            # name specified as second element explicitly\n            self.plugin, self._name = plugin\n\n        else:\n            self.plugin = plugin\n\n        priority = getattr(self.plugin, \"priority\", None)\n        self.priority: Tuple[int, int] = (\n            (batch_index, index) if priority is None else (priority, batch_index)\n        )\n\n        instantiate = getattr(self.plugin, \"instantiate\", False)\n        if instantiate and inspect.isclass(self.plugin):\n            self.plugin = self.plugin()\n\n        self.enabled = True  # type: bool\n\n    @propertyDOCS\n    def version(self) -&gt; Optional[str]:\n        \"\"\"Try to get the version of the plugin.\n\n        If the attribute `version` is definied, use it. Otherwise, try to check\n        if `__version__` is defined. If neither is defined, return None.\n\n        Returns:\n            In the priority order of plugin.version, plugin.__version__\n            and None\n        \"\"\"\n        return getattr(\n            self.plugin, \"version\", getattr(self.plugin, \"__version__\", None)\n        )\n\n    __version__ = version\n\n    @propertyDOCS\n    def name(self) -&gt; str:\n        \"\"\"Try to get the name of the plugin.\n\n        A lowercase name is recommended.\n\n        if `&lt;plugin&gt;.name` is defined, then the name is used. Otherwise,\n        `&lt;plugin&gt;.__name__` is used. Finally, `&lt;plugin&gt;.__class__.__name__` is\n        tried.\n\n        Raises:\n            NoPluginNameDefined: When a name cannot be retrieved.\n\n        Returns:\n            The name of the plugin\n        \"\"\"\n        if self._name is not None:\n            return self._name\n\n        try:\n            return self.plugin.name\n        except AttributeError:\n            pass\n\n        try:\n            return self.plugin.__name__.lower()\n        except AttributeError:\n            pass\n\n        try:\n            return self.plugin.__class__.__name__.lower()\n        except AttributeError:  # pragma: no cover\n            pass\n\n        raise NoPluginNameDefined(str(self.plugin))  # pragma: no cover\n\n    @propertyDOCS\n    def is_class(self) -&gt; bool:\n        \"\"\"Whether the plugin is a class\n\n        Returns:\n            True if the plugin is a class, False otherwise\n        \"\"\"\n        return inspect.isclass(self.plugin)\n\n    def enable(self) -&gt; None:DOCS\n        \"\"\"Enable this plugin\"\"\"\n        self.enabled = True\n\n    def disable(self) -&gt; None:DOCS\n        \"\"\"Disable this plugin\"\"\"\n        self.enabled = False\n\n    def hook(self, name: str) -&gt; Optional[SimplugImpl]:DOCS\n        \"\"\"Get the hook implementation of this plugin by name\n\n        Args:\n            name: The name of the hook\n\n        Returns:\n            The wrapper of the implementation. If the implementation is not\n                found or it's not decorated by `simplug.impl`, None will be\n                returned.\n        \"\"\"\n        ret = getattr(self.plugin, name, None)\n        if not isinstance(ret, SimplugImpl):\n            return None\n\n        return ret\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return self.plugin is other.plugin\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return not self.__eq__(other)\n\n\nclass SimplugHook:DOCS\n    \"\"\"A hook of a plugin\n\n    Args:\n        simplug_hooks: The SimplugHooks object\n        spec: The specification of the hook\n        required: Whether this hook is required to be implemented\n        result: Way to collect the results from the hook\n\n    Attributes:\n        name: The name of the hook\n        simplug_hooks: The SimplugHooks object\n        spec: The specification of the hook\n        required: Whether this hook is required to be implemented\n        result: Way to collect the results from the hook\n        debug: Whether to print debug messages\n        warn_sync_impl_on_async: Whether to warn about sync implementations\n            on async hooks\n    \"\"\"\n\n    simplug_hooks: \"SimplugHooks\"\n    spec: Callable[..., Any]\n    name: str\n    required: bool\n    result: Union[SimplugResult, Callable]\n    debug: bool\n    warn_sync_impl_on_async: bool\n\n    def __init__(\n        self,\n        simplug_hooks: \"SimplugHooks\",\n        spec: Callable[..., Any],\n        required: bool,\n        result: Union[SimplugResult, Callable],\n        warn_sync_impl_on_async: bool = False,\n    ) -&gt; None:\n        self.simplug_hooks = simplug_hooks\n        self.spec = spec\n        self.name = spec.__name__\n        self.required = required\n        self.result = result\n        self.debug = False\n        self.warn_sync_impl_on_async = warn_sync_impl_on_async\n\n    def _prepare_plugin_args(\n        self, plugin: SimplugWrapper, hook: SimplugImpl, args: Tuple[Any, ...]\n    ) -&gt; Tuple[Any, ...]:\n        \"\"\"Prepare arguments for calling a plugin hook implementation.\n\n        Args:\n            plugin: The plugin wrapper\n            hook: The hook implementation (SimplugImpl)\n            args: The original arguments to the hook\n\n        Returns:\n            Tuple of prepared arguments for the hook implementation\n        \"\"\"\n        if not hook.has_self:\n            return args\n\n        self_obj = plugin.plugin\n        if inspect.isclass(self_obj):\n            # Try to instantiate the class if it has no required parameters\n            try:\n                sig = inspect.signature(self_obj)\n                required_params = [\n                    p for p in sig.parameters.values()\n                    if (p.kind in (\n                        inspect.Parameter.POSITIONAL_ONLY,\n                        inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                    ) and p.default is inspect.Parameter.empty\n                      and p.name != \"self\")\n                ]\n                if not required_params:\n                    self_obj = self_obj()\n            except (TypeError, ValueError):  # pragma: no cover\n                # More specific exception handling\n                # Fallback to passing the class if instantiation fails\n                pass\n\n        return (self_obj, *args)\n\n    def _get_results(\n        self,\n        calls: List[SimplugImplCall],\n        plugin: Optional[str],\n        result: Optional[Union[SimplugResult, Callable, int]] = None,\n    ) -&gt; Any:\n        \"\"\"Get the results according to self.result\"\"\"\n        result = self.result if result is None else result\n\n        if callable(result):\n            if self.debug:\n                print(\n                    \"[simplug] - Gathering results using \"\n                    f\"custom function {result.__name__}\"\n                )\n            return result(calls)\n\n        if isinstance(result, SimplugResult):\n            result = result.value\n\n        # 0b  1    1    1    1111\n        #    TRY  ALL AVAIL   ID\n        if result &amp; 0b100_0000:\n            try:\n                return self._get_results(calls, plugin, result &amp; 0b011_1111)\n            except ResultUnavailableError:\n                return None\n\n        if result &amp; 0b010_0000:\n            out = [makecall(call) for call in calls]\n            if result == SimplugResult.ALL.value:\n                if self.debug:\n                    print(\"[simplug] - Returning all results\")\n                return out\n            if result == SimplugResult.ALL_AVAILS.value:\n                if self.debug:\n                    print(\"[simplug] - Returning all available (non-None) results\")\n                return [x for x in out if x is not None]\n            if result == SimplugResult.ALL_FIRST.value:\n                if not out:\n                    raise ResultUnavailableError\n                if self.debug:\n                    print(\"[simplug] - Returning first result\")\n                return out[0]\n            if result == SimplugResult.ALL_LAST.value:\n                if not out:\n                    raise ResultUnavailableError\n                if self.debug:\n                    print(\"[simplug] - Returning last result\")\n                return out[-1]\n            if result == SimplugResult.ALL_FIRST_AVAIL.value:\n                if not out or all(x is None for x in out):\n                    raise ResultUnavailableError\n                if self.debug:\n                    print(\"[simplug] - Returning first available (non-None) result\")\n                return next(x for x in out if x is not None)\n            if result == SimplugResult.ALL_LAST_AVAIL.value:\n                if not out or all(x is None for x in out):\n                    raise ResultUnavailableError\n                if self.debug:\n                    print(\"[simplug] - Returning last available (non-None) result\")\n                return next(x for x in reversed(out) if x is not None)\n\n        if result == SimplugResult.FIRST.value:\n            if not calls:\n                raise ResultUnavailableError\n            if self.debug:\n                print(\"[simplug] - Returning first result\")\n            return makecall(calls[0])\n        if result == SimplugResult.LAST.value:\n            if not calls:\n                raise ResultUnavailableError\n            if self.debug:\n                print(\"[simplug] - Returning last result\")\n            return makecall(calls[-1])\n        if result == SimplugResult.FIRST_AVAIL.value:\n            for call in calls:\n                ret = makecall(call)\n                if ret is not None:\n                    if self.debug:\n                        print(\"[simplug] - Returning first available (non-None) result\")\n                    return ret\n            raise ResultUnavailableError\n        if result == SimplugResult.LAST_AVAIL.value:\n            for call in reversed(calls):\n                ret = makecall(call)\n                if ret is not None:\n                    if self.debug:\n                        print(\"[simplug] - Returning last available (non-None) result\")\n                    return ret\n            raise ResultUnavailableError\n        if result == SimplugResult.SINGLE.value:\n            if not calls:\n                raise ResultUnavailableError\n            for call in calls:\n                if call.plugin == plugin:\n                    if self.debug:\n                        print(\n                            f\"[simplug] - Returning single result from plugin {plugin}\"\n                        )\n                    return makecall(call)\n            if plugin is not None:\n                raise ResultUnavailableError\n            if len(calls) &gt; 1:\n                warnings.warn(\n                    f\"More than one implementation of {self.name} found, \"\n                    \"but a single result is expected. Using the last one.\",\n                    MultipleImplsForSingleResultHookWarning,\n                )\n            if self.debug:\n                print(\n                    f\"[simplug] - Returning single result from the last plugin \"\n                    f\"{calls[-1].plugin}\"\n                )\n            return makecall(calls[-1])\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:DOCS\n        \"\"\"Call the hook in your system\n\n        Args:\n            *args: args for the hook\n            **kwargs: kwargs for the hook\n\n        Returns:\n            Depending on `self.result`:\n            - SimplugResult.ALL: Get all the results from the hook, as a list\n                including `NONE`s\n            - SimplugResult.ALL_AVAILS: Get all the results from the hook,\n                as a list, not including `NONE`s\n            - SimplugResult.FIRST: Get the none-`None` result from the\n                first plugin only (ordered by priority)\n            - SimplugResult.LAST: Get the none-`None` result from\n                the last plugin only\n        \"\"\"\n        self.simplug_hooks._sort_registry()\n        if (\n            self.result not in (SimplugResult.SINGLE, SimplugResult.TRY_SINGLE)\n            and \"__plugin\" in kwargs\n        ):\n            raise ValueError(\n                \"Cannot use __plugin with non-SimplugResult.(TRY_)SINGLE hooks\"\n            )\n\n        if self.debug:\n            print(\n                f\"[simplug] Calling hook {self.name} with args={args}, kwargs={kwargs}, \"\n                f\"result={self.result}\"\n            )\n\n        _plugin = kwargs.pop(\"__plugin\", None)\n        calls = []\n        for plugin in self.simplug_hooks._registry.values():\n            if not plugin.enabled:\n                continue\n            hook = plugin.hook(self.name)\n\n            if hook is not None:\n                plugin_args = self._prepare_plugin_args(plugin, hook, args)\n                if self.debug:\n                    print(f\"[simplug] - Pushing call {plugin.name}.{self.name}\")\n\n                calls.append(\n                    SimplugImplCall(plugin.name, hook.impl, plugin_args, kwargs)\n                )\n\n        return self._get_results(calls, plugin=_plugin)\n\n\nclass SimplugHookAsync(SimplugHook):DOCS\n    \"\"\"Wrapper of an async hook\"\"\"\n\n    async def _get_results(\n        self,\n        calls: List[SimplugImplCall],\n        plugin: Optional[str],\n        result: Optional[Union[SimplugResult, Callable, int]] = None,\n    ) -&gt; Any:\n        \"\"\"Get the results according to self.result\"\"\"\n        result = self.result if result is None else result\n\n        if callable(result):\n            if self.debug:\n                print(\n                    \"[simplug] - Gathering results using \"\n                    f\"custom async function {result.__name__}\"\n                )\n            return await result(calls)\n\n        if isinstance(result, SimplugResult):\n            result = result.value\n\n        # 0b  1    1    1    1111\n        #    TRY  ALL AVAIL   ID\n        if result &amp; 0b100_0000:\n            try:\n                return await self._get_results(\n                    calls,\n                    plugin,\n                    result &amp; 0b011_1111,\n                )\n            except ResultUnavailableError:\n                return None\n\n        if result &amp; 0b010_0000:\n            out = [await makecall(call, True) for call in calls]\n            if result == SimplugResult.ALL.value:\n                if self.debug:\n                    print(\"[simplug] - Returning all results\")\n                return out\n            if result == SimplugResult.ALL_AVAILS.value:\n                if self.debug:\n                    print(\"[simplug] - Returning all available (non-None) results\")\n                return [x for x in out if x is not None]\n            if result == SimplugResult.ALL_FIRST.value:\n                if not out:\n                    raise ResultUnavailableError\n                if self.debug:\n                    print(\"[simplug] - Returning first result\")\n                return out[0]\n            if result == SimplugResult.ALL_LAST.value:\n                if not out:\n                    raise ResultUnavailableError\n                if self.debug:\n                    print(\"[simplug] - Returning last result\")\n                return out[-1]\n            if result == SimplugResult.ALL_FIRST_AVAIL.value:\n                if not out or all(x is None for x in out):\n                    raise ResultUnavailableError\n                if self.debug:\n                    print(\"[simplug] - Returning first available (non-None) result\")\n                return next(x for x in out if x is not None)\n            if result == SimplugResult.ALL_LAST_AVAIL.value:\n                if not out or all(x is None for x in out):\n                    raise ResultUnavailableError\n                if self.debug:\n                    print(\"[simplug] - Returning last available (non-None) result\")\n                return next(x for x in reversed(out) if x is not None)\n\n        if result == SimplugResult.FIRST.value:\n            if not calls:\n                raise ResultUnavailableError\n            if self.debug:\n                print(\"[simplug] - Returning first result\")\n            return await makecall(calls[0], True)\n        if result == SimplugResult.LAST.value:\n            if not calls:\n                raise ResultUnavailableError\n            if self.debug:\n                print(\"[simplug] - Returning last result\")\n            return await makecall(calls[-1], True)\n        if result == SimplugResult.FIRST_AVAIL.value:\n            for call in calls:\n                ret = await makecall(call, True)\n                if ret is not None:\n                    if self.debug:\n                        print(\n                            \"[simplug] - Returning first available (non-None) result\"\n                        )\n                    return ret\n            raise ResultUnavailableError\n        if result == SimplugResult.LAST_AVAIL.value:\n            for call in reversed(calls):\n                ret = await makecall(call, True)\n                if ret is not None:\n                    if self.debug:\n                        print(\"[simplug] - Returning last available (non-None) result\")\n                    return ret\n            raise ResultUnavailableError\n        if result == SimplugResult.SINGLE.value:\n            if not calls:\n                raise ResultUnavailableError\n            for call in calls:\n                if call.plugin == plugin:\n                    if self.debug:\n                        print(\n                            f\"[simplug] - Returning single result from plugin {plugin}\"\n                        )\n                    return await makecall(call, True)\n            if plugin is not None:\n                raise ResultUnavailableError\n            if len(calls) &gt; 1:\n                warnings.warn(\n                    f\"More than one implementation of {self.name} found, \"\n                    \"but no plugin was specified. Using the last one.\",\n                    MultipleImplsForSingleResultHookWarning,\n                )\n            if self.debug:\n                print(\n                    f\"[simplug] - Returning single result from the last plugin \"\n                    f\"{calls[-1].plugin}\"\n                )\n            return await makecall(calls[-1], True)\n\n    async def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:DOCS\n        \"\"\"Call the hook in your system asynchronously\n\n        Args:\n            *args: args for the hook\n            **kwargs: kwargs for the hook\n\n        Returns:\n            Depending on `self.result`:\n            - SimplugResult.ALL: Get all the results from the hook, as a list\n                including `NONE`s\n            - SimplugResult.ALL_AVAILS: Get all the results from the hook,\n                as a list, not including `NONE`s\n            - SimplugResult.FIRST: Get the none-`None` result from the\n                first plugin only (ordered by priority)\n            - SimplugResult.LAST: Get the none-`None` result from\n                the last plugin only\n        \"\"\"\n        self.simplug_hooks._sort_registry()\n        if (\n            self.result not in (SimplugResult.SINGLE, SimplugResult.TRY_SINGLE)\n            and \"__plugin\" in kwargs\n        ):\n            raise ValueError(\n                \"Cannot use __plugin with non-SimplugResult.(TRY_)SINGLE hooks\"\n            )\n\n        if self.debug:\n            print(\n                f\"[simplug] Calling async hook {self.name} with args={args}, \"\n                f\"kwargs={kwargs}, result={self.result}\"\n            )\n\n        _plugin = kwargs.pop(\"__plugin\", None)\n        calls = []\n        for plugin in self.simplug_hooks._registry.values():\n            if not plugin.enabled:\n                continue\n            hook = plugin.hook(self.name)\n            if hook is None:  # pragma: no cover\n                continue\n\n            plugin_args = self._prepare_plugin_args(plugin, hook, args)\n            if self.debug:\n                print(f\"[simplug] - Pushing call {plugin.name}.{self.name}\")\n            calls.append(SimplugImplCall(plugin.name, hook.impl, plugin_args, kwargs))\n\n        return await self._get_results(calls, plugin=_plugin)\n\n\nclass SimplugHooks:DOCS\n    \"\"\"The hooks manager\n\n    Methods in this class are prefixed with a underscore to attributes clean\n    for hooks.\n\n    To call a hook in your system:\n    &gt;&gt;&gt; simplug.hooks.&lt;hook_name&gt;(&lt;args&gt;)\n\n    Attributes:\n        _registry: The plugin registry\n        _specs: The registry for the hook specs\n        _registry_sorted: Whether the plugin registry has been sorted already\n    \"\"\"\n\n    _registry: OrderedDiot\n    _specs: Dict[str, Union[\"SimplugHook\", \"SimplugHookAsync\"]]\n    _registry_sorted: bool\n\n    def __init__(self) -&gt; None:\n\n        self._registry = OrderedDiot()\n        self._specs: Dict[str, Union[SimplugHook, SimplugHookAsync]] = {}\n        self._registry_sorted = False\n\n    def _register(self, plugin: SimplugWrapper) -&gt; None:\n        \"\"\"Register a plugin (already wrapped by SimplugWrapper)\n\n        Args:\n            plugin: The plugin wrapper\n\n        Raises:\n            HookRequired: When a required hook is not implemented\n            HookSignatureDifferentFromSpec: When the arguments of a hook\n                implementation is different from its specification\n        \"\"\"\n        if plugin.name in self._registry and plugin != self._registry[plugin.name]:\n            raise PluginRegistered(\n                f\"Another plugin named {plugin.name} \" \"has already been registered.\"\n            )\n        # check if required hooks implemented\n        # and signature\n        has_self_warned: bool = False\n        for specname, spec in self._specs.items():\n            hook = plugin.hook(specname)\n            if spec.required and hook is None:\n                raise HookRequired(\n                    f\"{specname}, but not implemented \" f\"in plugin {plugin.name}\"\n                )\n            if hook is None:  # pragma: no cover\n                continue\n\n            impl_params = list(inspect.signature(hook.impl).parameters.keys())\n            spec_params = list(inspect.signature(spec.spec).parameters.keys())\n\n            if len(impl_params) &gt; 0 and impl_params[0] == \"self\":\n                impl_params = impl_params[1:]\n            if len(spec_params) &gt; 0 and spec_params[0] == \"self\":\n                spec_params = spec_params[1:]\n\n            if impl_params != spec_params:\n                raise HookSignatureDifferentFromSpec(\n                    f\"{specname!r} in plugin {plugin.name}\\n\"\n                    f\"Expect {spec_params}, \"\n                    f\"but got {impl_params}\"\n                )\n\n            if (\n                isinstance(spec, SimplugHookAsync)\n                and spec.warn_sync_impl_on_async\n                and not inspect.iscoroutinefunction(hook.impl)\n            ):\n                warnings.warn(\n                    f\"Sync implementation on async hook \"\n                    f\"{specname!r} in plugin {plugin.name}\",\n                    SyncImplOnAsyncSpecWarning,\n                )\n\n            if not isinstance(spec, SimplugHookAsync) and inspect.iscoroutinefunction(\n                hook.impl\n            ):\n                raise AsyncImplOnSyncSpecError(\n                    f\"Sync hook {specname!r} should be implemented by \"\n                    f\"a sync function, async implementation \"\n                    f\"'{hook.impl.__name__}' \"\n                    f\"found for plugin '{plugin.name}'\"\n                )\n\n            if hook.has_self and plugin.is_class and not has_self_warned:\n                warnings.warn(\n                    f\"The implementation '{hook.impl.__name__}' of hook \"\n                    f\"'{specname}' in plugin '{plugin.name}' might need an \"\n                    \"instance (self), but the plugin is a class. \"\n                    \"Please register your plugin as an instance of the class.\",\n                    ImplMightNeedInstanceWarning,\n                )\n                has_self_warned = True\n\n        self._registry[plugin.name] = plugin\n\n    def _sort_registry(self) -&gt; None:\n        \"\"\"Sort the registry by the priority only once\"\"\"\n        if self._registry_sorted:\n            return\n        orderedkeys = self._registry.__diot__[\"orderedkeys\"]\n        self._registry.__diot__[\"orderedkeys\"] = sorted(\n            orderedkeys, key=lambda plug: self._registry[plug].priority\n        )\n        self._registry_sorted = True\n\n    def __getattr__(self, name: str) -&gt; Union[\"SimplugHook\", \"SimplugHookAsync\"]:DOCS\n        \"\"\"Get the hook by name\n\n        Args:\n            name: The hook name\n\n        Returns:\n            The SimplugHook object\n\n        Raises:\n            NoSuchHookSpec: When the hook has no specification defined.\n        \"\"\"\n        try:\n            return self._specs[name]\n        except KeyError as exc:\n            raise NoSuchHookSpec(name).with_traceback(exc.__traceback__) from None\n\n\nclass SimplugContext:DOCS\n    \"\"\"The context manager for enabling or disabling a set of plugins\"\"\"\n\n    only: bool\n    plugins: Iterable[Any]\n    simplug: \"Simplug\"\n    orig_registry: OrderedDiot\n    orig_status: Dict[str, bool]\n\n    def __init__(self, simplug: \"Simplug\", plugins: Iterable[Any]) -&gt; None:\n        self.only = self._check_plugins(plugins)\n        self.plugins = plugins\n        self.simplug = simplug\n        self.orig_registry = simplug.hooks._registry.copy()\n        self.orig_status = {\n            name: plugin.enabled for name, plugin in self.orig_registry.items()\n        }\n\n    def _check_plugins(self, plugins: Iterable[Any]) -&gt; bool:\n        \"\"\"Check if the given plugins are valid and if all are only mode\n        (without prefixes) return True\"\"\"\n        onlys = [\n            isinstance(plug, str) and not plug.startswith((\"+\", \"-\"))\n            for plug in plugins\n        ]\n        if all(onlys):\n            return True\n        if any(onlys):\n            raise SimplugException(\n                \"The plugins should be all with prefixes (+, -) or without.\"\n            )\n        return False\n\n    def _raise(self, exc: Exception) -&gt; None:\n        \"\"\"Raise the exception and restore the original status\"\"\"\n        self.__exit__(*sys.exc_info())\n        raise exc\n\n    def __enter__(self) -&gt; None:\n        if self.only:\n            for plugin in self.orig_registry.values():\n                plugin.disable()\n\n        # raw\n        orig_names = list(self.orig_registry)\n        orig_raws = [plugin.plugin for plugin in self.orig_registry.values()]\n\n        for plugin in self.plugins:\n            if plugin in self.orig_registry.values():\n                plugin.enable()\n            elif plugin in orig_raws:\n                name = orig_names[orig_raws.index(plugin)]\n                self.orig_registry[name].enable()\n            elif not isinstance(plugin, str):\n                self.simplug.register(plugin)\n            elif plugin.startswith(\"-\"):\n                if plugin[1:] in self.orig_registry:\n                    self.orig_registry[plugin[1:]].disable()\n            else:\n                plugin = plugin[1:] if plugin.startswith(\"+\") else plugin\n                if plugin not in self.orig_registry:\n                    self._raise(NoSuchPlugin(plugin))\n                self.orig_registry[plugin].enable()\n\n    def __exit__(self, *exc: Any) -&gt; None:\n        self.simplug.hooks._registry = self.orig_registry\n        for name, status in self.orig_status.items():\n            self.simplug.hooks._registry[name].enabled = status\n\n\nclass Simplug:DOCS\n    \"\"\"The plugin manager for simplug\n\n    Attributes:\n        PROJECTS: The projects registry, to make sure the same `Simplug`\n            object by the name project name.\n\n        _batch_index: The batch index for plugin registration\n        hooks: The hooks manager\n        _inited: Whether `__init__` has already been called. Since the\n            `__init__` method will be called after `__new__`, this is used to\n            avoid `__init__` to be called more than once\n    \"\"\"\n\n    PROJECTS: Dict[str, \"Simplug\"] = {}\n\n    _batch_index: int\n    hooks: SimplugHooks\n    project: str\n    _inited: bool\n\n    def __new__(cls, project: str) -&gt; \"Simplug\":\n        if project not in cls.PROJECTS:\n            obj = super().__new__(cls)\n            obj.__init__(project)  # type: ignore\n            cls.PROJECTS[project] = obj\n\n        return cls.PROJECTS[project]\n\n    def __init__(self, project: str) -&gt; None:\n        if getattr(self, \"_inited\", None):\n            return\n        self._batch_index = 0\n        self.hooks = SimplugHooks()\n        self.project = project\n        self._inited = True\n\n    def load_entrypoints(DOCS\n        self,\n        group: Optional[str] = None,\n        only: Union[str, Iterable[str]] = (),\n    ) -&gt; None:\n        \"\"\"Load plugins from setuptools entry_points\n\n        Args:\n            group: The group of the entry_points\n            only: The names of the entry_points to load. If it's a str, it\n                means only load this entry_point. If it's a list of str, it\n                means load all the entry_points in the list.\n        \"\"\"\n        group = group or self.project\n\n        if isinstance(only, str):\n            only = [only]\n\n        try:\n            eps = metadata.entry_points(group=group)  # type: ignore\n        except TypeError:  # pragma: no cover\n            eps = metadata.entry_points().get(group, [])  # type: ignore\n\n        for ep in eps:\n            if only and ep.name not in only:\n                continue\n\n            plugin = ep.load()\n            self.register((plugin, ep.name))\n\n    def register(self, *plugins: Any) -&gt; None:DOCS\n        \"\"\"Register plugins\n\n        Args:\n            *plugins: The plugins, each of which could be a str, indicating\n                that the plugin is a module and will be imported by\n                `__import__`; or an object with the hook implementations as\n                its attributes.\n        \"\"\"\n        for i, plugin in enumerate(plugins):\n            plugin = SimplugWrapper(plugin, self._batch_index, i)\n            self.hooks._register(plugin)\n\n        self._batch_index += 1\n\n        if len(plugins) == 1 and callable(plugins[0]):\n            # allow to use as a decorator\n            return plugins[0]\n\n    def get_plugin(self, name: str, raw: bool = False) -&gt; Union[SimplugWrapper, Any]:DOCS\n        \"\"\"Get the plugin wrapper or the raw plugin object\n\n        Args:\n            name: The name of the plugin\n            raw: Get the raw plugin object (the one when it's registered)\n                If a plugin is a module and registered by its name, the\n                module is returned\n\n        Raises:\n            NoSuchPlugin: When the plugin does not exist\n\n        Returns:\n            The plugin wrapper or raw plugin\n        \"\"\"\n        if name not in self.hooks._registry:\n            raise NoSuchPlugin(name)\n        wrapper = self.hooks._registry[name]\n        return wrapper.plugin if raw else wrapper\n\n    def get_all_plugins(self, raw: bool = False) -&gt; Dict[str, Any]:DOCS\n        \"\"\"Get a mapping of all plugins\n\n        Args:\n            raw: Whether return the raw plugin or not\n                (the one when it's registered)\n                If a plugin is registered as a module by its name, the module\n                is returned.\n\n        Returns:\n            The mapping of all plugins\n        \"\"\"\n        if not raw:\n            return self.hooks._registry\n        return OrderedDiot(\n            [(name, plugin.plugin) for name, plugin in self.hooks._registry.items()]\n        )\n\n    def get_enabled_plugins(self, raw: bool = False) -&gt; Dict[str, Any]:DOCS\n        \"\"\"Get a mapping of all enabled plugins\n\n        Args:\n            raw: Whether return the raw plugin or not\n                (the one when it's registered)\n                If a plugin is registered as a module by its name, the module\n                is returned.\n\n        Returns:\n            The mapping of all enabled plugins\n        \"\"\"\n        return OrderedDiot(\n            [\n                (name, plugin.plugin if raw else plugin)\n                for name, plugin in self.hooks._registry.items()\n                if plugin.enabled\n            ]\n        )\n\n    def get_all_plugin_names(self) -&gt; List[str]:DOCS\n        \"\"\"Get the names of all plugins\n\n        Returns:\n            The names of all plugins\n        \"\"\"\n        return list(self.hooks._registry.keys())\n\n    def get_enabled_plugin_names(self) -&gt; List[str]:DOCS\n        \"\"\"Get the names of all enabled plugins\n\n        Returns:\n            The names of all enabled plugins\n        \"\"\"\n        return [name for name, plugin in self.hooks._registry.items() if plugin.enabled]\n\n    def plugins_context(DOCS\n        self, plugins: Optional[Iterable[Any]]\n    ) -&gt; Union[SimplugContext, nullcontext]:\n        \"\"\"A context manager with given plugins enabled or disabled\n\n        Args:\n            plugins: The plugin names or plugin objects\n                If the given plugin does not exist, register it.\n                None to not enable or disable anything.\n                When the context exits, the original status of the plugins\n                will be restored.\n                You can use `+` or `-` to enable or disable a plugin. If a\n                plugin is already enabled or disabled, it will be ignored.\n                If a plugin name is given without a prefix, it will be\n                enabled and all other plugins will be disabled. If a plugin\n                is given as a plugin itself, not a name, it will be regarded as\n                `+`.\n\n        Examples:\n            &gt;&gt;&gt; # enabled: plugin1, plugin2; disabled: plugin3\n            &gt;&gt;&gt; with simplug.plugins_context(['plugin3']):\n            &gt;&gt;&gt;     # enabled: plugin3; disabled: plugin1, plugin2\n            &gt;&gt;&gt;     pass\n            &gt;&gt;&gt; # enabled: plugin1, plugin2; disabled: plugin3\n            &gt;&gt;&gt; with simplug.plugins_context(['+plugin3']):\n            &gt;&gt;&gt;     # enabled: plugin1, plugin2, plugin3\n            &gt;&gt;&gt;     pass\n            &gt;&gt;&gt; # enabled: plugin1, plugin2; disabled: plugin3\n            &gt;&gt;&gt; with simplug.plugins_context(['-plugin1']):\n            &gt;&gt;&gt;     # enabled: plugin2; disabled: plugin1, plugin3\n            &gt;&gt;&gt;     pass\n            &gt;&gt;&gt; # enabled: plugin1, plugin2; disabled: plugin3\n            &gt;&gt;&gt; with simplug.plugins_context(['-plugin1', '+plugin3']):\n            &gt;&gt;&gt;     # enabled: plugin2, plugin3; disabled: plugin1\n            &gt;&gt;&gt;     pass\n\n        Returns:\n            The context manager\n        \"\"\"\n        if plugins is None:\n            return nullcontext()\n        return SimplugContext(self, plugins)\n\n    def enable(self, *names: str) -&gt; None:DOCS\n        \"\"\"Enable plugins by names\n\n        Args:\n            *names: The names of the plugin\n        \"\"\"\n        for name in names:\n            self.get_plugin(name).enable()\n\n    def disable(self, *names: str) -&gt; None:DOCS\n        \"\"\"Disable plugins by names\n\n        Args:\n            names: The names of the plugin\n        \"\"\"\n        for name in names:\n            self.get_plugin(name).disable()\n\n    def spec(DOCS\n        self,\n        hook: Optional[Callable[..., Any]] = None,\n        required: bool = False,\n        result: Union[SimplugResult, Callable] = SimplugResult.ALL_AVAILS,\n        warn_sync_impl_on_async: bool = True,\n    ) -&gt; Callable[..., Any]:\n        \"\"\"A decorator to define the specification of a hook\n\n        Args:\n            hook: The hook spec. If it is None, that means this decorator is\n                called with arguments, and it should be keyword arguments.\n                Otherwise, it is called like this `simplug.spec`\n            required: Whether this hook is required to be implemented.\n            result: How should we collect the results from the plugins\n            warn_sync_impl_on_async: Whether to warn when a sync implementation\n\n        Raises:\n            HookSpecExists: If a hook spec with the same name (`hook.__name__`)\n                 is already defined.\n\n        Returns:\n            A decorator function of other argument is passed, or the hook spec\n                itself.\n        \"\"\"\n        if hook is None:\n            return lambda hk: self.spec(\n                hk,\n                required=required,\n                result=result,\n                warn_sync_impl_on_async=warn_sync_impl_on_async,\n            )\n\n        hook_name = hook.__name__\n        if hook_name in self.hooks._specs:\n            raise HookSpecExists(hook_name)\n\n        if inspect.iscoroutinefunction(hook):\n            self.hooks._specs[hook_name] = SimplugHookAsync(\n                self.hooks,\n                hook,\n                required,\n                result,\n                warn_sync_impl_on_async,\n            )\n        else:\n            self.hooks._specs[hook_name] = SimplugHook(\n                self.hooks,\n                hook,\n                required,\n                result,\n            )\n\n        return hook\n\n    def impl(self, hook: Callable[..., Any]) -&gt; SimplugImpl:DOCS\n        \"\"\"A decorator for the implementation of a hook\n\n        Args:\n            hook: The hook implementation\n\n        Raises:\n            NoSuchHookSpec: When no specification is defined for this hook\n\n        Returns:\n            The wrapped hook implementation by `SimplugImpl`\n        \"\"\"\n        if hook.__name__ not in self.hooks._specs:\n            raise NoSuchHookSpec(hook.__name__)\n        return SimplugImpl(hook, \"self\" in inspect.signature(hook).parameters)\n</code></pre>"},{"location":"guide/async-hooks/","title":"Async Hooks","text":"<p>simplug provides first-class support for async hooks with automatic sync/async bridging.</p>"},{"location":"guide/async-hooks/#defining-async-hooks","title":"Defining Async Hooks","text":"<p>Use <code>async def</code> to define async hooks:</p> <pre><code>@simplug.spec\nasync def process_async(data):\n    \"\"\"Async hook specification.\"\"\"\n    # Async operations\n    result = await some_async_operation(data)\n    return result\n</code></pre>"},{"location":"guide/async-hooks/#implementing-async-hooks","title":"Implementing Async Hooks","text":""},{"location":"guide/async-hooks/#async-implementations","title":"Async Implementations","text":"<p>Implement async hooks with async functions:</p> <pre><code>class AsyncPlugin:\n    @simplug.impl\n    async def process_async(self, data):\n        return await asyncio.sleep(1, data.upper())\n</code></pre>"},{"location":"guide/async-hooks/#sync-implementations","title":"Sync Implementations","text":"<p>You can also implement async hooks with sync functions:</p> <pre><code>class SyncPlugin:\n    @simplug.impl\n    def process_async(self, data):\n        # Sync implementation of async hook\n        return data.lower()\n</code></pre> <p>Warning</p> <p>By default, simplug warns when a sync implementation is used on an async hook. See Suppressing Warnings.</p>"},{"location":"guide/async-hooks/#calling-async-hooks","title":"Calling Async Hooks","text":""},{"location":"guide/async-hooks/#using-asynciorun","title":"Using asyncio.run","text":"<p>Call async hooks from synchronous code:</p> <pre><code>import asyncio\n\nresult = asyncio.run(simplug.hooks.process_async(\"data\"))\n</code></pre>"},{"location":"guide/async-hooks/#within-async-context","title":"Within Async Context","text":"<p>Call from within async function:</p> <pre><code>async def main():\n    result = await simplug.hooks.process_async(\"data\")\n</code></pre>"},{"location":"guide/async-hooks/#mixed-sync-and-async","title":"Mixed Sync and Async","text":"<p>You can mix sync and async hooks:</p> <pre><code># Sync hook\n@simplug.spec\ndef process_sync(data):\n    pass\n\n# Async hook\n@simplug.spec\nasync def process_async(data):\n    pass\n\n# Call appropriately\nsync_result = simplug.hooks.process_sync(\"data\")\nasync_result = await simplug.hooks.process_async(\"data\")\n</code></pre>"},{"location":"guide/async-hooks/#suppressing-warnings","title":"Suppressing Warnings","text":"<p>Suppress warnings for sync implementations:</p> <pre><code># Warn by default\n@simplug.spec()\nasync def async_hook(data):\n    pass\n\nclass Plugin:\n    @simplug.impl\n    def async_hook(self, data):\n        return data  # Sync on async - warns\n\n# Suppress warning\n@simplug.spec(warn_sync_impl_on_async=False)\nasync def async_hook(data):\n    pass\n\nclass Plugin:\n    @simplug.impl\n    def async_hook(self, data):\n        return data  # No warning\n</code></pre>"},{"location":"guide/async-hooks/#error-handling","title":"Error Handling","text":""},{"location":"guide/async-hooks/#async-errors-in-sync-code","title":"Async Errors in Sync Code","text":"<p>Errors from async hooks in sync context are properly wrapped:</p> <pre><code>class FailingPlugin:\n    @simplug.impl\n    async def failing_hook(self, data):\n        raise ValueError(\"Failed\")\n\n# Call from sync code\ntry:\n    result = asyncio.run(simplug.hooks.failing_hook(\"data\"))\nexcept ResultError as e:\n    print(f\"Error: {e}\")\n    # Error: plugin=MyPlugin; spec=[async]failing_hook\n</code></pre>"},{"location":"guide/async-hooks/#sync-errors-in-async-context","title":"Sync Errors in Async Context","text":"<pre><code>class FailingPlugin:\n    @simplug.impl\n    def failing_hook(self, data):\n        raise ValueError(\"Failed\")\n\n# Call from async code\ntry:\n    result = await simplug.hooks.failing_hook(\"data\")\nexcept ResultError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"guide/async-hooks/#result-collection-with-async-hooks","title":"Result Collection with Async Hooks","text":"<p>All result collection strategies work with async hooks:</p> <pre><code># Collect all results\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\nasync def process(data):\n    pass\n\nresults = await simplug.hooks.process(\"data\")\n# Returns: ['RESULT1', 'RESULT2']\n</code></pre> <p>The result collection happens asynchronously - all plugin implementations run concurrently (depending on how you call them).</p>"},{"location":"guide/async-hooks/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/async-hooks/#concurrent-execution","title":"Concurrent Execution","text":"<p>When calling async hooks, consider execution strategy:</p> <pre><code># Sequential execution (waits for each)\nresults = []\nfor plugin in plugins:\n    results.append(await plugin.hook(data))\n\n# Concurrent execution (faster if hooks are independent)\nimport asyncio\ntasks = [plugin.hook(data) for plugin in plugins]\nresults = await asyncio.gather(*tasks)\n</code></pre> <p>simplug calls implementations sequentially in the sorted plugin order. For true parallel execution, implement this pattern in your code.</p>"},{"location":"guide/async-hooks/#sync-overhead","title":"Sync Overhead","text":"<p>Sync implementations on async hooks add minimal overhead:</p> <pre><code># Sync implementation called from async context\nasync def hook(data):\n    return sync_impl(data)\n</code></pre> <p>The sync function is executed and then wrapped in a coroutine.</p>"},{"location":"guide/async-hooks/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom simplug import Simplug, SimplugResult\n\nsimplug = Simplug('asyncapp')\n\n# Define hooks\n@simplug.spec\nasync def fetch_data(self, url):\n    \"\"\"Fetch data from URL.\"\"\"\n\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\nasync def process_data(self, data):\n    \"\"\"Process fetched data.\"\"\"\n\n# Implement plugins\nclass HttpPlugin:\n    @simplug.impl\n    async def fetch_data(self, url):\n        import aiohttp\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as resp:\n                return await resp.text()\n\nclass TransformPlugin:\n    @simplug.impl\n    async def process_data(self, data):\n        return data.upper()\n\nclass LoggerPlugin:\n    @simplug.impl\n    async def process_data(self, data):\n        print(f\"Processing: {len(data)} bytes\")\n        return None\n\n# Register\nsimplug.register(HttpPlugin, TransformPlugin, LoggerPlugin)\n\n# Use\nasync def main():\n    # Fetch data\n    data = await simplug.hooks.fetch_data('https://example.com')\n\n    # Process\n    results = await simplug.hooks.process_data(data)\n    print(results)\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/async-hooks/#mixing-sync-and-async-implementations","title":"Mixing Sync and Async Implementations","text":"<pre><code>@simplug.spec(warn_sync_impl_on_async=False)\nasync def transform(self, data):\n    \"\"\"Transform data - can be sync or async.\"\"\"\n\nclass SyncPlugin:\n    @simplug.impl\n    def transform(self, data):\n        return data.upper()\n\nclass AsyncPlugin:\n    @simplug.impl\n    async def transform(self, data):\n        # Simulate async work\n        await asyncio.sleep(0.1)\n        return data.lower()\n\n# Both work together\nasync def main():\n    result = await simplug.hooks.transform(\"Hello\")\n    print(result)  # ['HELLO', 'hello']\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/async-hooks/#best-practices","title":"Best Practices","text":"<ol> <li>Use async hooks for async operations - I/O, network calls, database queries</li> <li>Keep implementations consistent - If hook is async, prefer async implementations</li> <li>Handle sync implementations gracefully - Use <code>warn_sync_impl_on_async=False</code> when needed</li> <li>Consider performance - Sequential execution vs concurrent patterns</li> <li>Document async requirements - Clear when hooks are async</li> </ol>"},{"location":"guide/async-hooks/#next-steps","title":"Next Steps","text":"<ul> <li>Defining Hooks - Specifying async hooks</li> <li>Implementing Hooks - Creating async implementations</li> <li>Result Collection - Collecting async results</li> </ul>"},{"location":"guide/defining-hooks/","title":"Defining Hooks","text":"<p>Hook specifications define the extension points in your application that plugins can implement.</p>"},{"location":"guide/defining-hooks/#basic-syntax","title":"Basic Syntax","text":"<p>Use the <code>@simplug.spec</code> decorator to define a hook:</p> <pre><code>from simplug import Simplug, SimplugResult\n\nsimplug = Simplug('myapp')\n\n@simplug.spec\ndef my_hook(arg1, arg2):\n    \"\"\"My hook documentation.\"\"\"\n</code></pre>"},{"location":"guide/defining-hooks/#decorator-options","title":"Decorator Options","text":"<p>The <code>@simplug.spec</code> decorator accepts the following parameters:</p>"},{"location":"guide/defining-hooks/#required","title":"required","text":"<p>Whether this hook must be implemented by at least one plugin.</p> <pre><code>@simplug.spec(required=True)\ndef critical_hook(data):\n    \"\"\"This hook must be implemented.\"\"\"\n</code></pre> <p>If no plugin implements a required hook, calling it will raise <code>HookRequired</code> exception.</p>"},{"location":"guide/defining-hooks/#result","title":"result","text":"<p>Specifies how to collect results from plugin implementations. See Result Collection for all available strategies.</p> <pre><code>from simplug import SimplugResult\n\n# Collect all non-None results\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\ndef process_data(data):\n    \"\"\"Process data and return results.\"\"\"\n</code></pre>"},{"location":"guide/defining-hooks/#warn_sync_impl_on_async","title":"warn_sync_impl_on_async","text":"<p>For async hooks, whether to warn when a plugin provides a synchronous implementation.</p> <pre><code># Warn if plugin provides sync implementation\n@simplug.spec(warn_sync_impl_on_async=True)\nasync def async_hook(data):\n    \"\"\"Async hook with sync implementation warning.\"\"\"\n</code></pre> <p>Default is <code>True</code>. Set to <code>False</code> to suppress warnings.</p>"},{"location":"guide/defining-hooks/#parameter-names-and-defaults","title":"Parameter Names and Defaults","text":"<p>Hook parameters are matched by name between spec and implementation.</p>"},{"location":"guide/defining-hooks/#specifying-default-values","title":"Specifying Default Values","text":"<p>You can specify default values in the spec:</p> <pre><code>@simplug.spec\ndef configure(self, timeout=30, retries=3):\n    \"\"\"Configure with defaults.\"\"\"\n</code></pre>"},{"location":"guide/defining-hooks/#implementation-requirements","title":"Implementation Requirements","text":"<p>Implementations must have the same parameter names, but default values are not required:</p> <pre><code>@plugin.impl\ndef configure(self, timeout, retries):\n    # Default values not needed in implementation\n    print(f\"timeout={timeout}, retries={retries}\")\n</code></pre> <p>Note</p> <p>Default values in implementation functions are ignored. Always specify defaults in the hook specification.</p>"},{"location":"guide/defining-hooks/#the-self-parameter","title":"The <code>self</code> Parameter","text":"<p>When defining hooks inside a class, you can use <code>self</code> as the first parameter:</p> <pre><code>class MySpec:\n    @simplug.spec\n    def method_hook(self, data):\n        \"\"\"Method hook specification.\"\"\"\n</code></pre> <p>When the hook is called, <code>self</code> will be <code>None</code>. This is just a naming convention for clarity.</p>"},{"location":"guide/defining-hooks/#async-hooks","title":"Async Hooks","text":"<p>Define async hooks using <code>async def</code>:</p> <pre><code>@simplug.spec\nasync def process_async(data):\n    \"\"\"Async hook specification.\"\"\"\n</code></pre> <p>See Async Hooks for more details on async hooks.</p>"},{"location":"guide/defining-hooks/#signature-validation","title":"Signature Validation","text":"<p>simplug validates that hook implementations match the specification:</p> <pre><code>@simplug.spec\ndef my_hook(arg1, arg2):\n    \"\"\"Hook specification.\"\"\"\n\nclass BadPlugin:\n    @simplug.impl\n    def my_hook(wrong_arg):  # Mismatched signature!\n        pass\n\nsimplug.register(BadPlugin)  # Raises HookSignatureDifferentFromSpec\n</code></pre> <p>Parameter names must match exactly (excluding <code>self</code>).</p>"},{"location":"guide/defining-hooks/#hook-names","title":"Hook Names","text":"<p>Hook names are derived from the function name:</p> <pre><code>@simplug.spec\ndef process_data(data):  # Hook name is \"process_data\"\n    pass\n</code></pre> <p>Duplicate hook names are not allowed:</p> <pre><code>@simplug.spec\ndef my_hook(data):\n    pass\n\n@simplug.spec\ndef my_hook(data):  # Raises HookSpecExists\n    pass\n</code></pre>"},{"location":"guide/defining-hooks/#complete-example","title":"Complete Example","text":"<pre><code>from simplug import Simplug, SimplugResult\n\nsimplug = Simplug('dataapp')\n\nclass DataHooks:\n    @simplug.spec(required=True)\n    def validate(self, data):\n        \"\"\"Validate data - required hook.\"\"\"\n\n    @simplug.spec(result=SimplugResult.ALL_AVAILS)\n    def transform(self, data):\n        \"\"\"Transform data - collect all non-None results.\"\"\"\n\n    @simplug.spec(result=SimplugResult.FIRST_AVAIL)\n    def get_cache_key(self, data):\n        \"\"\"Get cache key - first available result only.\"\"\"\n\n# Now plugins can implement these hooks\n</code></pre>"},{"location":"guide/defining-hooks/#next-steps","title":"Next Steps","text":"<ul> <li>Implementing Hooks - How to implement hook specifications</li> <li>Result Collection - All result collection strategies</li> <li>Async Hooks - Working with async hooks</li> </ul>"},{"location":"guide/entrypoints/","title":"Setuptools Entrypoints","text":"<p>simplug can automatically discover and load plugins from installed packages using setuptools entry points.</p>"},{"location":"guide/entrypoints/#what-are-entrypoints","title":"What are Entrypoints?","text":"<p>Setuptools entry points allow third-party packages to register plugins that your application can discover. This enables:</p> <ul> <li>Automatic plugin discovery from installed packages</li> <li>No need to manually import and register plugins</li> <li>Decoupled plugin distribution</li> </ul>"},{"location":"guide/entrypoints/#defining-entrypoints","title":"Defining Entrypoints","text":""},{"location":"guide/entrypoints/#in-plugin-package","title":"In Plugin Package","text":"<p>Add entry points to your plugin package's <code>setup.py</code> or <code>pyproject.toml</code>:</p> <pre><code># setup.py\nfrom setuptools import setup\n\nsetup(\n    name='my-plugin',\n    packages=['my_plugin'],\n    install_requires=['simplug'],\n    entry_points={\n        'myapp': [\n            'my-plugin = my_plugin:MyPlugin',\n        ]\n    }\n)\n</code></pre> <p>Or in <code>pyproject.toml</code>:</p> <pre><code>[project.entry-points.\"myapp\"]\nmy-plugin = \"my_plugin:MyPlugin\"\n</code></pre> <p>The entry point group (<code>myapp</code> in this example) must match your simplug project name.</p>"},{"location":"guide/entrypoints/#plugin-code","title":"Plugin Code","text":"<p>Your plugin just needs to implement hooks:</p> <pre><code># my_plugin/__init__.py\nfrom simplug import Simplug\n\n# Assume simplug instance is available at import time\n# In practice, your app loads entrypoints after defining hooks\n\nclass MyPlugin:\n    name = \"my_plugin\"\n\n    @simplug.impl\n    def process_data(self, data):\n        return data.upper()\n</code></pre>"},{"location":"guide/entrypoints/#loading-entrypoints","title":"Loading Entrypoints","text":""},{"location":"guide/entrypoints/#load-all-plugins","title":"Load All Plugins","text":"<p>Load all plugins for your project:</p> <pre><code>from simplug import Simplug\n\nsimplug = Simplug('myapp')\n\n# Define hooks first\n@simplug.spec\ndef process_data(data):\n    pass\n\n# Load all entry points for 'myapp' group\nsimplug.load_entrypoints()\n</code></pre>"},{"location":"guide/entrypoints/#load-specific-plugins","title":"Load Specific Plugins","text":"<p>Load only specific entry points:</p> <pre><code># Load only one\nsimplug.load_entrypoints(only='my-plugin')\n\n# Load multiple\nsimplug.load_entrypoints(only=['plugin1', 'plugin2'])\n</code></pre>"},{"location":"guide/entrypoints/#custom-group","title":"Custom Group","text":"<p>Load from a different group:</p> <pre><code># Load from custom group\nsimplug.load_entrypoints(group='custom_group')\n</code></pre>"},{"location":"guide/entrypoints/#timing-considerations","title":"Timing Considerations","text":""},{"location":"guide/entrypoints/#define-hooks-before-loading","title":"Define Hooks Before Loading","text":"<p>Always define your hooks before loading entry points:</p> <pre><code>from simplug import Simplug\n\nsimplug = Simplug('myapp')\n\n# Define hooks first\n@simplug.spec\ndef process_data(data):\n    pass\n\n# Then load entry points\nsimplug.load_entrypoints()\n</code></pre> <p>Entry point plugins implement hooks defined before loading.</p>"},{"location":"guide/entrypoints/#load-after-registration","title":"Load After Registration","text":"<p>You can mix manual registration and entry points:</p> <pre><code># Manually register core plugins\nsimplug.register(CorePlugin)\n\n# Then load external plugins\nsimplug.load_entrypoints()\n</code></pre>"},{"location":"guide/entrypoints/#entrypoint-names","title":"Entrypoint Names","text":"<p>Entry point names become plugin names. Use descriptive names:</p> <pre><code>entry_points={\n    'myapp': [\n        'data-processor = my_plugin:DataProcessor',\n        'validator = my_plugin:Validator,\n        'logger = my_plugin:Logger,\n    ]\n}\n</code></pre> <p>Plugin names: <code>data_processor</code>, <code>validator</code>, <code>logger</code>.</p>"},{"location":"guide/entrypoints/#complete-example","title":"Complete Example","text":""},{"location":"guide/entrypoints/#application","title":"Application","text":"<pre><code># app/main.py\nfrom simplug import Simplug\n\nsimplug = Simplug('myapp')\n\n# Define hooks\nclass AppHooks:\n    @simplug.spec\n    def process(self, data):\n        \"\"\"Process data.\"\"\"\n\n    @simplug.spec\n    def on_startup(self):\n        \"\"\"Called on startup.\"\"\"\n\n# Load plugins from entry points\nsimplug.load_entrypoints()\n\n# Use\nresults = simplug.hooks.process(\"test\")\nprint(f\"Results: {results}\")\n\n# Call startup\nsimplug.hooks.on_startup()\n</code></pre>"},{"location":"guide/entrypoints/#plugin-package","title":"Plugin Package","text":"<pre><code># my_plugin/setup.py\nfrom setuptools import setup\n\nsetup(\n    name='my-plugin',\n    version='1.0.0',\n    packages=['my_plugin'],\n    py_modules=['my_plugin'],\n    install_requires=['simplug'],\n    entry_points={\n        'myapp': [\n            'my-plugin = my_plugin:MyPlugin',\n        ]\n    }\n)\n</code></pre> <pre><code># my_plugin/__init__.py\nfrom simplug import Simplug\n\n# Import simplug instance or it will be passed automatically\n# For entrypoints, app must be imported first\n\nclass MyPlugin:\n    name = \"my_plugin\"\n    version = \"1.0.0\"\n\n    @simplug.impl\n    def process(self, data):\n        return data.upper()\n\n    @simplug.impl\n    def on_startup(self):\n        print(\"MyPlugin initialized!\")\n</code></pre>"},{"location":"guide/entrypoints/#installation-and-usage","title":"Installation and Usage","text":"<pre><code># Install application\npip install myapp\n\n# Install plugin (development mode)\ncd my_plugin\npip install -e .\n\n# Or install plugin (published)\npip install my-plugin\n\n# Run app - plugins automatically loaded\npython -m app\n</code></pre>"},{"location":"guide/entrypoints/#discovering-available-plugins","title":"Discovering Available Plugins","text":"<p>You can discover available entry points:</p> <pre><code>from importlib import metadata\n\neps = metadata.entry_points(group='myapp')\nfor ep in eps:\n    print(f\"Found plugin: {ep.name} from {ep.value}\")\n</code></pre>"},{"location":"guide/entrypoints/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive entry point names - Clear and unique</li> <li>Follow naming conventions - Use kebab-case for entry point names</li> <li>Document required hooks - Specify which hooks your plugin implements</li> <li>Handle missing dependencies - Plugin should fail gracefully if deps missing</li> <li>Version your plugins - Help users track compatibility</li> </ol>"},{"location":"guide/entrypoints/#next-steps","title":"Next Steps","text":"<ul> <li>Defining Hooks - Specifying hooks for plugins</li> <li>Implementing Hooks - Creating plugins</li> <li>Plugin Registry - Managing loaded plugins</li> </ul>"},{"location":"guide/implementing-hooks/","title":"Implementing Hooks","text":"<p>Plugins implement hooks defined by your application's specifications.</p>"},{"location":"guide/implementing-hooks/#basic-syntax","title":"Basic Syntax","text":"<p>Use the <code>@simplug.impl</code> decorator to implement a hook:</p> <pre><code>class MyPlugin:\n    @simplug.impl\n    def my_hook(arg1, arg2):\n        \"\"\"Implement the hook.\"\"\"\n        return arg1 + arg2\n</code></pre>"},{"location":"guide/implementing-hooks/#plugin-structure","title":"Plugin Structure","text":"<p>Plugins can be classes or modules. They just need to have methods decorated with <code>@simplug.impl</code>.</p>"},{"location":"guide/implementing-hooks/#class-based-plugins","title":"Class-Based Plugins","text":"<pre><code>class DataProcessor:\n    @simplug.impl\n    def process_data(self, data):\n        return data.upper()\n\nsimplug.register(DataProcessor)\n</code></pre>"},{"location":"guide/implementing-hooks/#module-based-plugins","title":"Module-Based Plugins","text":"<pre><code># mymodule.py\n@simplug.impl\ndef process_data(data):\n    return data.upper()\n\n# main.py\nsimplug.register('mymodule')\n</code></pre>"},{"location":"guide/implementing-hooks/#parameter-matching","title":"Parameter Matching","text":"<p>Your implementation must match the hook specification's parameter names:</p> <pre><code># Specification\n@simplug.spec\ndef my_hook(arg1, arg2):\n    pass\n\n# Valid implementation\n@plugin.impl\ndef my_hook(arg1, arg2):\n    return arg1 + arg2\n\n# Invalid implementation (wrong names)\n@plugin.impl\ndef my_hook(x, y):  # Raises HookSignatureDifferentFromSpec\n    return x + y\n</code></pre>"},{"location":"guide/implementing-hooks/#the-self-parameter","title":"The <code>self</code> Parameter","text":"<p>When a hook specification includes <code>self</code>, your implementation can optionally include it:</p> <pre><code># Specification\n@simplug.spec\ndef method_hook(self, data):\n    pass\n\n# Implementation with self\nclass MyPlugin:\n    @simplug.impl\n    def method_hook(self, data):\n        # self is the plugin instance\n        return self.transform(data)\n\n    def transform(self, data):\n        return data.upper()\n</code></pre> <p>If you include <code>self</code>, simplug will automatically pass the plugin instance when calling the hook.</p>"},{"location":"guide/implementing-hooks/#returning-values","title":"Returning Values","text":"<p>Hook implementations can return values that are collected based on the hook's result strategy:</p> <pre><code>@plugin.impl\ndef process_data(data):\n    return data.upper()  # Return value\n\n@plugin.impl\ndef process_data(data):\n    print(data)  # Side effect, returns None\n</code></pre> <p>See Result Collection for how return values are collected.</p>"},{"location":"guide/implementing-hooks/#plugin-names","title":"Plugin Names","text":"<p>simplug determines plugin names in this priority order:</p> <ol> <li><code>name</code> attribute</li> <li><code>__name__</code> attribute (lowercased)</li> <li><code>__class__.__name__</code> attribute (lowercased)</li> </ol> <pre><code>class MyPlugin:\n    name = \"custom_name\"  # Will use this\n\n# Or\nclass MyPlugin:\n    pass  # Will use 'myplugin' (lowercased __name__)\n</code></pre>"},{"location":"guide/implementing-hooks/#plugin-instance-vs-class","title":"Plugin Instance vs Class","text":"<p>You can register either a class or an instance:</p> <pre><code># Register as class (simplug auto-instantiates if no __init__ params)\nsimplug.register(MyPlugin)\n\n# Register as instance (use when __init__ needs params)\ninstance = MyPlugin(config={'debug': True})\nsimplug.register(instance)\n</code></pre>"},{"location":"guide/implementing-hooks/#auto-instantiation","title":"Auto-instantiation","text":"<p>If a class has no required constructor parameters, simplug auto-instantiates it:</p> <pre><code>class SimplePlugin:\n    @plugin.impl\n    def hook(self):\n        pass\n\n# Auto-instantiated\nsimplug.register(SimplePlugin)\n\nclass ComplexPlugin:\n    def __init__(self, config):\n        self.config = config\n\n    @plugin.impl\n    def hook(self):\n        pass\n\n# Must pass instance\nsimplug.register(ComplexPlugin(config={}))\n</code></pre>"},{"location":"guide/implementing-hooks/#plugin-attributes","title":"Plugin Attributes","text":"<p>Plugins can define additional attributes:</p>"},{"location":"guide/implementing-hooks/#name","title":"name","text":"<p>Custom plugin name:</p> <pre><code>class MyPlugin:\n    name = \"my_custom_name\"\n</code></pre>"},{"location":"guide/implementing-hooks/#version","title":"version","text":"<p>Plugin version:</p> <pre><code>class MyPlugin:\n    version = \"1.0.0\"\n    # Or\n    __version__ = \"1.0.0\"\n</code></pre>"},{"location":"guide/implementing-hooks/#priority","title":"priority","text":"<p>Plugin execution priority (lower = higher priority):</p> <pre><code>class MyPlugin:\n    priority = -1  # Executes before default (0)\n</code></pre> <p>See Priority System for details.</p>"},{"location":"guide/implementing-hooks/#instantiate","title":"instantiate","text":"<p>Force auto-instantiation even with parameters:</p> <pre><code>class MyPlugin:\n    instantiate = True  # Force instantiation\n</code></pre>"},{"location":"guide/implementing-hooks/#multiple-hooks-in-one-plugin","title":"Multiple Hooks in One Plugin","text":"<p>A single plugin can implement multiple hooks:</p> <pre><code>class MultiHookPlugin:\n    @simplug.impl\n    def on_startup(self, config):\n        print(\"Starting...\")\n\n    @simplug.impl\n    def on_shutdown(self):\n        print(\"Shutting down...\")\n\n    @simplug.impl\n    def process_data(self, data):\n        return data.upper()\n\nsimplug.register(MultiHookPlugin)\n</code></pre>"},{"location":"guide/implementing-hooks/#complete-example","title":"Complete Example","text":"<pre><code>from simplug import Simplug\n\nsimplug = Simplug('textapp')\n\n# Specification\n@simplug.spec\ndef transform_text(self, text):\n    pass\n\n@simplug.spec\ndef validate_text(self, text):\n    pass\n\n# Plugin implementations\nclass UpperCasePlugin:\n    name = \"uppercase\"\n\n    @simplug.impl\n    def transform_text(self, text):\n        return text.upper()\n\nclass ReversePlugin:\n    name = \"reverse\"\n\n    @simplug.impl\n    def transform_text(self, text):\n        return text[::-1]\n\nclass LengthValidator:\n    name = \"length_validator\"\n\n    @simplug.impl\n    def validate_text(self, text):\n        if len(text) &gt; 100:\n            raise ValueError(\"Text too long\")\n        return True\n\n# Register plugins\nsimplug.register(UpperCasePlugin, ReversePlugin, LengthValidator)\n\n# Use\ntransforms = simplug.hooks.transform_text(\"hello\")\nprint(transforms)  # ['HELLO', 'olleh']\n\nis_valid = simplug.hooks.validate_text(\"test\")\nprint(is_valid)  # [True]\n</code></pre>"},{"location":"guide/implementing-hooks/#next-steps","title":"Next Steps","text":"<ul> <li>Plugin Registry - Managing plugins</li> <li>Priority System - Controlling execution order</li> <li>Result Collection - How results are gathered</li> </ul>"},{"location":"guide/plugin-registry/","title":"Plugin Registry","text":"<p>The plugin registry manages all registered plugins and their state.</p>"},{"location":"guide/plugin-registry/#registering-plugins","title":"Registering Plugins","text":""},{"location":"guide/plugin-registry/#registering-classes-or-instances","title":"Registering Classes or Instances","text":"<p>Register plugins using <code>register()</code> method:</p> <pre><code># Register class (auto-instantiated if no __init__ params)\nsimplug.register(MyPlugin)\n\n# Register instance (use when __init__ needs params)\ninstance = MyPlugin(config={})\nsimplug.register(instance)\n</code></pre>"},{"location":"guide/plugin-registry/#registering-multiple-plugins","title":"Registering Multiple Plugins","text":"<p>Register multiple plugins at once:</p> <pre><code>simplug.register(PluginA, PluginB, PluginC)\n</code></pre>"},{"location":"guide/plugin-registry/#registering-by-module-name","title":"Registering by Module Name","text":"<p>Register a plugin by module string:</p> <pre><code>simplug.register('mypackage.plugins.myplugin')\n</code></pre> <p>The module will be imported automatically.</p>"},{"location":"guide/plugin-registry/#querying-plugins","title":"Querying Plugins","text":""},{"location":"guide/plugin-registry/#get-plugin-by-name","title":"Get Plugin by Name","text":"<p>Get a specific plugin:</p> <pre><code>plugin = simplug.get_plugin('myplugin')\n\n# Get raw plugin object\nplugin_obj = simplug.get_plugin('myplugin', raw=True)\n</code></pre> <p>Raises <code>NoSuchPlugin</code> if plugin not found.</p>"},{"location":"guide/plugin-registry/#get-all-plugins","title":"Get All Plugins","text":"<p>Get all registered plugins:</p> <pre><code># Get plugin wrappers\nplugins = simplug.get_all_plugins()\n\n# Get raw plugin objects\nplugins = simplug.get_all_plugins(raw=True)\n</code></pre> <p>Returns an <code>OrderedDiot</code> (ordered dictionary).</p>"},{"location":"guide/plugin-registry/#get-enabled-plugins","title":"Get Enabled Plugins","text":"<p>Get only enabled plugins:</p> <pre><code># Get enabled plugin wrappers\nenabled = simplug.get_enabled_plugins()\n\n# Get enabled raw objects\nenabled = simplug.get_enabled_plugins(raw=True)\n</code></pre>"},{"location":"guide/plugin-registry/#get-plugin-names","title":"Get Plugin Names","text":"<p>Get list of all plugin names:</p> <pre><code>all_names = simplug.get_all_plugin_names()\n# Returns: ['plugin1', 'plugin2', 'plugin3']\n</code></pre> <p>Get enabled plugin names:</p> <pre><code>enabled_names = simplug.get_enabled_plugin_names()\n# Returns: ['plugin1', 'plugin3']\n</code></pre> <p>Names are in execution order (sorted by priority).</p>"},{"location":"guide/plugin-registry/#enabling-and-disabling-plugins","title":"Enabling and Disabling Plugins","text":""},{"location":"guide/plugin-registry/#disable-plugins","title":"Disable Plugins","text":"<p>Temporarily disable plugins:</p> <pre><code># Disable specific plugin\nsimplug.disable('plugin1')\n\n# Disable multiple\nsimplug.disable('plugin1', 'plugin2')\n</code></pre>"},{"location":"guide/plugin-registry/#enable-plugins","title":"Enable Plugins","text":"<p>Re-enable disabled plugins:</p> <pre><code># Enable specific plugin\nsimplug.enable('plugin1')\n\n# Enable multiple\nsimplug.enable('plugin1', 'plugin2')\n</code></pre>"},{"location":"guide/plugin-registry/#direct-plugin-access","title":"Direct Plugin Access","text":"<p>You can also access plugins directly:</p> <pre><code># Get plugin and disable\nplugin = simplug.get_plugin('myplugin')\nplugin.disable()\n\n# Get plugin and enable\nplugin = simplug.get_plugin('myplugin')\nplugin.enable()\n</code></pre>"},{"location":"guide/plugin-registry/#plugin-context-manager","title":"Plugin Context Manager","text":"<p>Temporarily enable or disable plugins using a context manager:</p> <pre><code># Enable only specific plugins\nwith simplug.plugins_context(['plugin1', 'plugin2']):\n    # Only plugin1 and plugin2 are active\n    simplug.hooks.my_hook(data)\n# Original state restored\n</code></pre>"},{"location":"guide/plugin-registry/#context-syntax","title":"Context Syntax","text":"<pre><code># Enable only these plugins\nwith simplug.plugins_context(['plugin1', 'plugin2']):\n    pass\n\n# Add plugin\nwith simplug.plugins_context(['+plugin3']):\n    # plugin3 added to enabled set\n    pass\n\n# Remove plugin\nwith simplug.plugins_context(['-plugin1']):\n    # plugin1 removed from enabled set\n    pass\n\n# Multiple operations\nwith simplug.plugins_context(['-plugin1', '+plugin3']):\n    # plugin1 disabled, plugin3 enabled\n    pass\n\n# No changes\nwith simplug.plugins_context(None):\n    # All plugins maintain current state\n    pass\n</code></pre>"},{"location":"guide/plugin-registry/#context-rules","title":"Context Rules","text":"<ul> <li>All plugins without prefix (<code>+</code>/<code>-</code>): Only those are enabled, all others disabled</li> <li>With prefixes: All start current state, then apply changes</li> <li>Context exit: Original state automatically restored</li> </ul>"},{"location":"guide/plugin-registry/#plugin-names","title":"Plugin Names","text":"<p>Plugin names are determined in this priority:</p> <ol> <li><code>_name</code> attribute (when loaded from entrypoint)</li> <li><code>name</code> attribute</li> <li><code>__name__</code> attribute (lowercased)</li> <li><code>__class__.__name__</code> attribute (lowercased)</li> </ol> <pre><code>class MyPlugin:\n    name = \"custom_name\"  # Will use \"custom_name\"\n\n# Or\nclass MyPlugin:\n    pass  # Will use \"myplugin\" (lowercased)\n</code></pre>"},{"location":"guide/plugin-registry/#duplicate-plugin-names","title":"Duplicate Plugin Names","text":"<p>Registering a plugin with existing name raises error:</p> <pre><code>simplug.register(Plugin1)  # Name: \"plugin1\"\nsimplug.register(Plugin2)  # Also has name: \"plugin1\"\n# Raises PluginRegistered\n</code></pre> <p>Same plugin object is allowed:</p> <pre><code>p = Plugin1()\nsimplug.register(p)\nsimplug.register(p)  # Same object, no error\n</code></pre>"},{"location":"guide/plugin-registry/#inspection-methods","title":"Inspection Methods","text":""},{"location":"guide/plugin-registry/#check-if-plugin-exists","title":"Check if Plugin Exists","text":"<pre><code>try:\n    plugin = simplug.get_plugin('myplugin')\n    exists = True\nexcept NoSuchPlugin:\n    exists = False\n</code></pre>"},{"location":"guide/plugin-registry/#get-plugin-count","title":"Get Plugin Count","text":"<pre><code>all_count = len(simplug.get_all_plugins())\nenabled_count = len(simplug.get_enabled_plugins())\n</code></pre>"},{"location":"guide/plugin-registry/#list-disabled-plugins","title":"List Disabled Plugins","text":"<pre><code>all_plugins = set(simplug.get_all_plugin_names())\nenabled_plugins = set(simplug.get_enabled_plugin_names())\ndisabled = all_plugins - enabled_plugins\n</code></pre>"},{"location":"guide/plugin-registry/#complete-example","title":"Complete Example","text":"<pre><code>from simplug import Simplug\n\nsimplug = Simplug('app')\n\n# Define hook\n@simplug.spec\ndef process(data):\n    pass\n\n# Create plugins\nclass PluginA:\n    name = \"plugin_a\"\n    priority = -1  # Higher priority\n\n    @simplug.impl\n    def process(self, data):\n        return f\"A: {data}\"\n\nclass PluginB:\n    name = \"plugin_b\"\n\n    @simplug.impl\n    def process(self, data):\n        return f\"B: {data}\"\n\nclass PluginC:\n    name = \"plugin_c\"\n    priority = 1  # Lower priority\n\n    @simplug.impl\n    def process(self, data):\n        return f\"C: {data}\"\n\n# Register all\nsimplug.register(PluginA, PluginB, PluginC)\n\n# Check registry\nprint(f\"All plugins: {simplug.get_all_plugin_names()}\")\n# Output: ['plugin_a', 'plugin_b', 'plugin_c']\n\nprint(f\"Enabled: {simplug.get_enabled_plugin_names()}\")\n# Output: ['plugin_a', 'plugin_b', 'plugin_c']\n\n# Disable one\nsimplug.disable('plugin_b')\nprint(f\"Enabled: {simplug.get_enabled_plugin_names()}\")\n# Output: ['plugin_a', 'plugin_c']\n\n# Use context to enable only plugin_b\nwith simplug.plugins_context(['plugin_b']):\n    print(f\"In context: {simplug.get_enabled_plugin_names()}\")\n    # Output: ['plugin_b']\n    result = simplug.hooks.process(\"test\")\n    print(result)  # [\"B: test\"]\n\n# Context exit - original state restored\nprint(f\"After context: {simplug.get_enabled_plugin_names()}\")\n# Output: ['plugin_a', 'plugin_c']\n</code></pre>"},{"location":"guide/plugin-registry/#next-steps","title":"Next Steps","text":"<ul> <li>Priority System - How execution order is determined</li> <li>Setuptools Entrypoints - Loading plugins from packages</li> <li>Implementing Hooks - Creating plugins</li> </ul>"},{"location":"guide/priority-system/","title":"Priority System","text":"<p>simplug's priority system determines the execution order of plugins.</p>"},{"location":"guide/priority-system/#how-priority-works","title":"How Priority Works","text":"<p>Priority is a 2-element tuple: <code>(priority_attr, batch_index)</code></p> <ul> <li>Lower values = Higher priority (execute first)</li> <li>Priority attr = First sorting element</li> <li>Batch index = Second sorting element (registration order within a batch)</li> </ul>"},{"location":"guide/priority-system/#setting-priority","title":"Setting Priority","text":""},{"location":"guide/priority-system/#using-priority-attribute","title":"Using priority Attribute","text":"<p>Set priority on plugin class:</p> <pre><code>class HighPriorityPlugin:\n    priority = -1  # Executes before default (0)\n\nclass NormalPlugin:\n    priority = 0  # Default priority\n\nclass LowPriorityPlugin:\n    priority = 1  # Executes after default\n</code></pre>"},{"location":"guide/priority-system/#no-priority-attribute","title":"No priority Attribute","text":"<p>If no <code>priority</code> attribute, uses <code>(batch_index, register_index)</code>:</p> <pre><code>class Plugin:\n    pass  # No priority attribute\n\n# Register in batch 0\nsimplug.register(Plugin1, Plugin2)\n# Plugin1 priority: (0, 0)\n# Plugin2 priority: (0, 1)\n# Plugin1 executes first\n\n# Register in batch 1\nsimplug.register(Plugin3)\n# Plugin3 priority: (1, 0)\n# Plugins 1 and 2 execute before 3\n</code></pre>"},{"location":"guide/priority-system/#batch-index","title":"Batch Index","text":"<p>Plugins registered in the same <code>register()</code> call share the same batch index:</p> <pre><code># Batch 0\nsimplug.register(PluginA, PluginB, PluginC)\n# All have batch_index=0\n# Sorted by (priority_attr, 0) then (priority_attr, 1) then (priority_attr, 2)\n\n# Batch 1\nsimplug.register(PluginD)\n# batch_index=1\n# Executes after all batch 0 plugins\n</code></pre>"},{"location":"guide/priority-system/#priority-examples","title":"Priority Examples","text":""},{"location":"guide/priority-system/#override-behavior","title":"Override Behavior","text":"<p>Use negative priority to override default plugins:</p> <pre><code>class DefaultPlugin:\n    priority = 0  # Default priority\n\n    @simplug.impl\n    def process(self, data):\n        return f\"Default: {data}\"\n\nclass OverridePlugin:\n    priority = -1  # Higher priority\n\n    @simplug.impl\n    def process(self, data):\n        return f\"Override: {data}\"\n\n# OverridePlugin executes first\nsimplug.register(DefaultPlugin, OverridePlugin)\nresults = simplug.hooks.process(\"test\")\n# Returns: ['Override: test', 'Default: test']\n</code></pre>"},{"location":"guide/priority-system/#chain-of-fallbacks","title":"Chain of Fallbacks","text":"<p>Use priority for fallback chains:</p> <pre><code>class CachePlugin:\n    priority = -2  # First - check cache\n\n    @simplug.impl\n    def get_value(self, key):\n        return cache.get(key)\n\nclass ConfigPlugin:\n    priority = -1  # Second - check config\n\n    @simplug.impl\n    def get_value(self, key):\n        return config.get(key)\n\nclass DefaultPlugin:\n    priority = 0  # Last - use default\n\n    @simplug.impl\n    def get_value(self, key):\n        return DEFAULTS[key]\n\n# Tries cache, then config, then default\nvalue = simplug.hooks.get_value('timeout')\n</code></pre>"},{"location":"guide/priority-system/#layers-of-processing","title":"Layers of Processing","text":"<p>Use priority to layer transformations:</p> <pre><code>class ParserPlugin:\n    priority = -2  # First - parse data\n\n    @simplug.impl\n    def process(self, data):\n        return json.loads(data)\n\nclass ValidatorPlugin:\n    priority = -1  # Second - validate\n\n    @simplug.impl\n    def process(self, data):\n        if not valid(data):\n            raise ValueError(\"Invalid\")\n        return data\n\nclass EnricherPlugin:\n    priority = 0  # Last - enrich\n\n    @simplug.impl\n    def process(self, data):\n        data['timestamp'] = datetime.now().isoformat()\n        return data\n\n# Data flows through parser -&gt; validator -&gt; enricher\nresult = simplug.hooks.process(raw_json)\n</code></pre>"},{"location":"guide/priority-system/#execution-order","title":"Execution Order","text":""},{"location":"guide/priority-system/#complete-example","title":"Complete Example","text":"<pre><code>from simplug import Simplug\n\nsimplug = Simplug('priorityapp')\n\n@simplug.spec\ndef process(data):\n    pass\n\n# Register in different orders and priorities\nclass PluginA:\n    priority = -1\n\n    @simplug.impl\n    def process(self, data):\n        return f\"A: {data}\"\n\nclass PluginB:\n    # No priority - uses batch index\n\n    @simplug.impl\n    def process(self, data):\n        return f\"B: {data}\"\n\nclass PluginC:\n    priority = 1\n\n    @simplug.impl\n    def process(self, data):\n        return f\"C: {data}\"\n\nclass PluginD:\n    priority = -2\n\n    @simplug.impl\n    def process(self, data):\n        return f\"D: {data}\"\n\n# Register: D (batch 0), A, B (batch 1), C (batch 2)\nsimplug.register(PluginD)\nsimplug.register(PluginA, PluginB)\nsimplug.register(PluginC)\n\n# Execution order:\n# 1. PluginD (priority -2, batch 0)\n# 2. PluginA (priority -1, batch 1)\n# 3. PluginB (no priority, batch 1, index 1)\n# 4. PluginC (priority 1, batch 2)\n\nresults = simplug.hooks.process(\"test\")\n# Returns: ['D: test', 'A: test', 'B: test', 'C: test']\n</code></pre>"},{"location":"guide/priority-system/#checking-order","title":"Checking Order","text":"<p>Inspect plugin order:</p> <pre><code># Get all plugin names in execution order\nnames = simplug.get_all_plugin_names()\nprint(names)\n\n# Or inspect priority\nfor name in names:\n    plugin = simplug.get_plugin(name)\n    print(f\"{name}: priority={plugin.priority}\")\n</code></pre>"},{"location":"guide/priority-system/#dynamic-priority-changes","title":"Dynamic Priority Changes","text":"<p>You can modify priority after registration:</p> <pre><code>plugin = simplug.get_plugin('myplugin')\nplugin.priority = -1  # Change priority\n\n# Note: Registry is sorted once per hook call\n# Priority changes apply to subsequent calls\n</code></pre> <p>For permanent priority changes, use the <code>priority</code> attribute on the plugin class.</p>"},{"location":"guide/priority-system/#negative-priorities","title":"Negative Priorities","text":"<p>Negative priorities allow core plugins to always execute first:</p> <pre><code># Core functionality\nclass CorePlugin:\n    priority = -100  # Always first\n\n    @simplug.impl\n    def process(self, data):\n        return self.core_logic(data)\n\n# User plugins\nclass UserPlugin:\n    priority = 0  # After core\n\n    @simplug.impl\n    def process(self, data):\n        return self.user_logic(data)\n</code></pre>"},{"location":"guide/priority-system/#best-practices","title":"Best Practices","text":"<ol> <li>Use meaningful priority values - Clear hierarchy (e.g., -10, -5, 0, 5, 10)</li> <li>Document priority behavior - Explain why a plugin needs specific priority</li> <li>Avoid tight priority ranges - Leave room for future plugins</li> <li>Consider batch index - Same-batch plugins execute in registration order</li> <li>Use result strategies wisely - <code>FIRST_AVAIL</code> often works well with priorities</li> </ol>"},{"location":"guide/priority-system/#common-priority-patterns","title":"Common Priority Patterns","text":"Pattern Priority Range Use Case Core system -100 to -10 Always execute first Critical extensions -10 to -5 Override defaults Default functionality 0 Standard priority Optional features 5 to 10 Enhance functionality Rare features 10+ Last resort"},{"location":"guide/priority-system/#next-steps","title":"Next Steps","text":"<ul> <li>Plugin Registry - Managing plugin state</li> <li>Result Collection - How results are collected</li> <li>Implementing Hooks - Creating plugins</li> </ul>"},{"location":"guide/result-collection/","title":"Result Collection Strategies","text":"<p>simplug provides 18 built-in strategies for collecting results from hook implementations, plus support for custom collectors.</p>"},{"location":"guide/result-collection/#overview","title":"Overview","text":"<p>Result strategies are specified in hook definition using the <code>result</code> parameter:</p> <pre><code>from simplug import Simplug, SimplugResult\n\n@simplug.spec(result=SimplugResult.ALL_AVAILS)\ndef my_hook(data):\n    pass\n</code></pre>"},{"location":"guide/result-collection/#strategy-categories","title":"Strategy Categories","text":"<p>Strategies are organized into three categories:</p> <ol> <li>ALL strategies - Execute all plugins and collect results</li> <li>FIRST/LAST strategies - Execute only first or last plugin</li> <li>SINGLE strategies - Execute a single plugin by name</li> </ol>"},{"location":"guide/result-collection/#all-strategies","title":"ALL Strategies","text":"<p>Execute all plugin implementations and collect results.</p>"},{"location":"guide/result-collection/#all","title":"ALL","text":"<p>Collect all results including <code>None</code> values.</p> <pre><code>@simplug.spec(result=SimplugResult.ALL)\ndef process(data):\n    pass\n\n# Returns: ['result1', None, 'result3']\n</code></pre> <p>Use when you need to know which plugins returned <code>None</code>.</p>"},{"location":"guide/result-collection/#all_avails","title":"ALL_AVAILS","text":"<p>Collect all non-<code>None</code> results.</p> <pre><code>@simplug.spec(result=SimplugResult.ALL_AVAILS)\ndef process(data):\n    pass\n\n# Returns: ['result1', 'result3']\n</code></pre> <p>Most common strategy for collecting results.</p>"},{"location":"guide/result-collection/#all_first","title":"ALL_FIRST","text":"<p>Execute all plugins, return first result (even if <code>None</code>).</p> <pre><code>@simplug.spec(result=SimplugResult.ALL_FIRST)\ndef process(data):\n    pass\n\n# Returns: 'result1' or None\n# All plugins execute\n</code></pre> <p>Use when you want all side effects but only care about first result.</p>"},{"location":"guide/result-collection/#all_last","title":"ALL_LAST","text":"<p>Execute all plugins, return last result (even if <code>None</code>).</p> <pre><code>@simplug.spec(result=SimplugResult.ALL_LAST)\ndef process(data):\n    pass\n\n# Returns: 'result3' or None\n# All plugins execute\n</code></pre>"},{"location":"guide/result-collection/#all_first_avail","title":"ALL_FIRST_AVAIL","text":"<p>Execute all plugins, return first non-<code>None</code> result.</p> <pre><code>@simplug.spec(result=SimplugResult.ALL_FIRST_AVAIL)\ndef process(data):\n    pass\n\n# Returns: 'result2' (first non-None)\n# All plugins execute\n</code></pre>"},{"location":"guide/result-collection/#all_last_avail","title":"ALL_LAST_AVAIL","text":"<p>Execute all plugins, return last non-<code>None</code> result.</p> <pre><code>@simplug.spec(result=SimplugResult.ALL_LAST_AVAIL)\ndef process(data):\n    pass\n\n# Returns: 'result3' (last non-None)\n# All plugins execute\n</code></pre>"},{"location":"guide/result-collection/#firstlast-strategies","title":"FIRST/LAST Strategies","text":"<p>Execute only first or last plugin, skipping others.</p>"},{"location":"guide/result-collection/#first","title":"FIRST","text":"<p>Execute only first plugin, return its result (even if <code>None</code>).</p> <pre><code>@simplug.spec(result=SimplugResult.FIRST)\ndef process(data):\n    pass\n\n# Returns: 'result1' or None\n# Only first plugin executes\n</code></pre>"},{"location":"guide/result-collection/#last","title":"LAST","text":"<p>Execute only last plugin, return its result (even if <code>None</code>).</p> <pre><code>@simplug.spec(result=SimplugResult.LAST)\ndef process(data):\n    pass\n\n# Returns: 'result3' or None\n# Only last plugin executes\n</code></pre>"},{"location":"guide/result-collection/#first_avail","title":"FIRST_AVAIL","text":"<p>Execute plugins until first non-<code>None</code> result, then stop.</p> <pre><code>@simplug.spec(result=SimplugResult.FIRST_AVAIL)\ndef process(data):\n    pass\n\n# Returns: 'result2' (first non-None)\n# Plugins 1 and 2 execute, then stop\n</code></pre> <p>Good for fallback chains - first plugin to provide valid result wins.</p>"},{"location":"guide/result-collection/#last_avail","title":"LAST_AVAIL","text":"<p>Execute plugins in reverse until first non-<code>None</code> result, then stop.</p> <pre><code>@simplug.spec(result=SimplugResult.LAST_AVAIL)\ndef process(data):\n    pass\n\n# Returns: 'result2' (first non-None from end)\n# Plugins 3 and 2 execute, then stop\n</code></pre> <p>Good for overriding behavior - last valid result wins.</p>"},{"location":"guide/result-collection/#single-strategies","title":"SINGLE Strategies","text":"<p>Execute a single plugin by name.</p>"},{"location":"guide/result-collection/#single","title":"SINGLE","text":"<p>Execute plugin specified by <code>__plugin</code> parameter.</p> <pre><code>@simplug.spec(result=SimplugResult.SINGLE)\ndef get_value(key):\n    pass\n\n# Execute specific plugin\nresult = simplug.hooks.get_value('key', __plugin='plugin1')\n\n# If no __plugin, uses last plugin\nresult = simplug.hooks.get_value('key')\n</code></pre> <p>Warning</p> <p>If no <code>__plugin</code> specified and multiple implementations exist, a warning is raised.</p>"},{"location":"guide/result-collection/#try-strategies","title":"TRY Strategies","text":"<p>Return <code>None</code> instead of raising exception when no result available.</p> <p>All strategies above have <code>TRY_*</code> variants that: - Return <code>None</code> instead of raising <code>ResultUnavailableError</code> - Otherwise behave identically</p>"},{"location":"guide/result-collection/#available-try-strategies","title":"Available TRY Strategies","text":"<ul> <li><code>TRY_ALL</code> - Return <code>None</code> if no results</li> <li><code>TRY_ALL_AVAILS</code> - Return <code>None</code> if no non-<code>None</code> results</li> <li><code>TRY_ALL_FIRST</code> - Return <code>None</code> if no results</li> <li><code>TRY_ALL_LAST</code> - Return <code>None</code> if no results</li> <li><code>TRY_ALL_FIRST_AVAIL</code> - Return <code>None</code> if no non-<code>None</code> results</li> <li><code>TRY_ALL_LAST_AVAIL</code> - Return <code>None</code> if no non-<code>None</code> results</li> <li><code>TRY_FIRST</code> - Return <code>None</code> if no result</li> <li><code>TRY_LAST</code> - Return <code>None</code> if no result</li> <li><code>TRY_FIRST_AVAIL</code> - Return <code>None</code> if no non-<code>None</code> result</li> <li><code>TRY_LAST_AVAIL</code> - Return <code>None</code> if no non-<code>None</code> result</li> <li><code>TRY_SINGLE</code> - Return <code>None</code> if plugin not found</li> </ul> <p>Example:</p> <pre><code># Would raise ResultUnavailableError if no results\n@simplug.spec(result=SimplugResult.FIRST_AVAIL)\ndef get_data(data):\n    pass\n\n# Returns None instead of raising exception\n@simplug.spec(result=SimplugResult.TRY_FIRST_AVAIL)\ndef get_data(data):\n    pass\n</code></pre>"},{"location":"guide/result-collection/#custom-collectors","title":"Custom Collectors","text":"<p>You can provide your own result collector function:</p> <pre><code>def custom_collector(calls):\n    \"\"\"Custom collector function.\n\n    Args:\n        calls: List of SimplugImplCall tuples\n            Each tuple: (plugin_name, impl_function, args, kwargs)\n\n    Returns:\n        Collected result in any format\n    \"\"\"\n    results = [call.impl(*call.args, **call.kwargs) for call in calls]\n    return '; '.join(str(r) for r in results if r)\n\n@simplug.spec(result=custom_collector)\ndef process(data):\n    pass\n\n# Returns: \"result1; result2; result3\"\n</code></pre>"},{"location":"guide/result-collection/#async-custom-collectors","title":"Async Custom Collectors","text":"<p>For async hooks, provide an async collector:</p> <pre><code>async def async_custom_collector(calls):\n    results = [await call.impl(*call.args, **call.kwargs) for call in calls]\n    return sum(results)\n\n@simplug.spec(result=async_custom_collector)\nasync def process_async(data):\n    pass\n</code></pre>"},{"location":"guide/result-collection/#strategy-selection-guide","title":"Strategy Selection Guide","text":"Use Case Recommended Strategy Collect all results <code>ALL_AVAILS</code> First valid result (chain) <code>FIRST_AVAIL</code> Last valid result (override) <code>LAST_AVAIL</code> Only first plugin <code>FIRST</code> Only last plugin <code>LAST</code> Execute all, return first <code>ALL_FIRST</code> Execute all, return last <code>ALL_LAST</code> Single plugin by name <code>SINGLE</code> Handle no results gracefully Use <code>TRY_*</code> variants"},{"location":"guide/result-collection/#examples","title":"Examples","text":""},{"location":"guide/result-collection/#collecting-transformations","title":"Collecting Transformations","text":"<pre><code>@simplug.spec(result=SimplugResult.ALL_AVAILS)\ndef transform_text(text):\n    pass\n\nclass Plugins:\n    @simplug.impl\n    def transform_text(self, text):\n        return text.upper()\n\n    @simplug.impl\n    def transform_text(self, text):\n        return text.lower()\n\n    @simplug.impl\n    def transform_text(self, text):\n        return text.title()\n\nresults = simplug.hooks.transform_text(\"hello\")\n# Returns: ['HELLO', 'hello', 'Hello']\n</code></pre>"},{"location":"guide/result-collection/#fallback-chain","title":"Fallback Chain","text":"<pre><code>@simplug.spec(result=SimplugResult.FIRST_AVAIL)\ndef get_config(key):\n    \"\"\"Get config from first available source.\"\"\"\n\n# Plugins in priority order (env vars, then file, then defaults)\nclass EnvConfig:\n    priority = -1  # First\n    @simplug.impl\n    def get_config(self, key):\n        return os.environ.get(key)\n\nclass FileConfig:\n    priority = 0\n    @simplug.impl\n    def get_config(self, key):\n        # Returns None if not found\n        return read_config(key)\n\nclass DefaultConfig:\n    priority = 1  # Last (always has value)\n    @simplug.impl\n    def get_config(self, key):\n        return DEFAULTS.get(key)\n\nvalue = simplug.hooks.get_config('timeout')\n# Returns env value if set, file value if set, else default\n</code></pre>"},{"location":"guide/result-collection/#validation-pipeline","title":"Validation Pipeline","text":"<pre><code>@simplug.spec(result=SimplugResult.ALL)\ndef validate(data):\n    \"\"\"Run all validations.\"\"\"\n\nclass SchemaValidator:\n    @simplug.impl\n    def validate(self, data):\n        if not validate_schema(data):\n            raise ValueError(\"Invalid schema\")\n\nclass BusinessValidator:\n    @simplug.impl\n    def validate(self, data):\n        if not meets_business_rules(data):\n            raise ValueError(\"Invalid business rules\")\n\nresults = simplug.hooks.validate(data)\n# Returns [None, ValueError] - all validators run\n</code></pre>"},{"location":"guide/result-collection/#next-steps","title":"Next Steps","text":"<ul> <li>Implementing Hooks - How to implement hooks</li> <li>Priority System - Control execution order</li> <li>Async Hooks - Async-specific considerations</li> </ul>"}]}